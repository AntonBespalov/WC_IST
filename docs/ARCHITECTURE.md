# Архитектура ПО источника сварочного тока

Цели этого документа:
1) Зафиксировать модульную структуру прошивки и границы ответственности.
2) Обеспечить тестируемость (host unit / SIL / HIL / on-target / power bench).
3) Зафиксировать safety-инварианты на уровне архитектуры (аппаратный safe state, latch, watchdog).
4) Снизить риск “скрытых” зависимостей от HAL/RTOS и непредсказуемых таймингов.

Источники правды:
- `docs/PROJECT_CONTEXT.md` — железо/тайминги/политики (Ground Truth)
- `docs/GLOSSARY.md` — определения терминов
- `docs/ENGINEERING_CONTRACT.md` — общий инженерный контракт разработки (defensive design, safety/RT, proof)

Терминология: в тексте «Источник»/«плата источника» может также называться «ИСТ» или «УСПФ» (см. `docs/GLOSSARY.md`).

---

## 1) Архитектурные принципы (не обсуждается без PR)
### P1. Разделение логики и железа
- Алгоритмы (управление/измерение/безопасность) реализуются без зависимостей от STM32 HAL.
- Доступ к периферии — через адаптеры (HAL-layer), которые инжектируются в “ядро”.

Зачем: юнит-тесты на ПК и SIL становятся возможными без эмуляции STM32.

### P2. Безопасное отключение — аппаратно
- Критические аварии должны выключать силовую часть аппаратно (TIM1 BKIN/BKIN2 + по возможности независимый DRV_EN/INH).
- ПО обязано корректно обработать событие и отчитаться, но “рубильник” не должен ждать RTOS/ISR.

### P3. Детерминизм и бюджет времени
- Критичные циклы имеют бюджет времени и измеряются на железе (GPIO/trace).
- При overrun поведение определено (controlled stop или fault по политике).

### P4. Наблюдаемость как часть архитектуры
- Встроенные счётчики ошибок/overrun/таймаутов — обязательны.
- Поддержка record/replay (если есть внешняя память по QSPI, например PSRAM/FRAM) — как инструмент диагностики и регрессии.

---

## 2) Верхнеуровневая схема модулей (логическая)
Архитектура намеренно слоистая:

### 2.1 Core (тестируется на ПК / SIL)
1) `control_core`
- ПИ/ограничители/anti-windup/slew-rate
- вычисление управляющего воздействия (duty/phase/enable request)
- не знает про TIM1/регистры/FreeRTOS

2) `measurement_core`
- преобразование raw->физика, диагностика (stuck/sat/timeout/пределы)
- фильтрация (mavg и т.п.)
- выдаёт измеренные значения + признаки качества данных

3) `safety_supervisor`
- агрегирует fault-условия (измерение, связь, драйвер, overrun)
- определяет разрешение сварки, latch/recovery
- формирует “команду безопасного состояния” для HAL-слоя

4) `protocol_core`
- протоколы верхнего уровня: обмен с ТК (EtherCAT PDO) и обмен “плата ↔ ПК” (PCcom4)
- seq/CRC/таймауты на логическом уровне (не привязано к транспорту)
- формирование статуса/ответа

5) `state_machine`
- IDLE/ARMED/WELD/FAULT и правила переходов
- опирается на `safety_supervisor`

### 2.2 HAL/Platform (тестируется on-target)
1) `pwm_hal` (TIM1)
- инициализация TIM1, управление выходами, применение duty
- контроль/конфигурация Break (BKIN/BKIN2), dead-time, lock
- предоставляет функции “apply_output(request)” и “force_off()”

2) `adc_hal`
- SPI/DMA транзакции, таймерные триггеры выборки (если применимо)
- выдаёт буфер raw-данных и статусы ошибок (timeout/CRC/…)
- не содержит бизнес-логики фильтров

3) `comms_hal`
- EtherCAT (COMX/FMC) транспорт для RxPDO/TxPDO (см. `docs/protocols/PROTOCOL_TK_ETHERCAT.md`) + (опц.) legacy CAN FD драйвер/очереди (см. `docs/protocols/PROTOCOL_TK.md`)
- “сырой” транспорт для `protocol_core`

4) `watchdog_hal`
- внутренний IWDG/WWDG + внешний супервизор (если есть)
- интерфейс: kick/monitor

5) `logging_hal`
- SWO/USART/USB-UART/логгер во внешнюю память (QSPI) (record/replay/осциллографирование)
- обеспечивает минимально-инвазивное логирование
- интерфейс “плата ↔ ПК” по USB-UART может использовать PCcom4 (см. `docs/protocols/PCCOM4.02.md`)

### 2.3 Инфраструктура
- `diag_counters` — единый набор счётчиков и метрик
- `timebase` — монотонный таймштамп (микросекунды/тики)
- `asserts` — политика assert/ошибок (в т.ч. production-safe)
- `settings_store` — хранение настроек/калибровок (version + CRC + defaults) с инвариантом: запись во Flash **только** в `IDLE` (PWM OFF), без влияния на PWM-домен (см. `docs/PROJECT_CONTEXT.md` / раздел 5)

---

## 3) Потоки выполнения и контуры времени
### 3.0 Временные домены (контракт детерминизма)
В проекте есть минимум 4 домена времени:
- **PWM-домен (1–4 кГц)**: измерение → агрегация по периоду → регулятор → применение на следующий период.
- **Домен 250 мкс (ТК, EtherCAT PDO, 4 кГц)**: приём/валидация команд, публикация “последней валидной” команды, формирование ответа/статуса.
- **Домен 1 мс (процесс/диагностика/логирование)**: агрегация “медленных” статусов, сервис/не-RT действия, статистика (если нужно — decimation от 4 кГц).
- **Async fault-домен (мкс)**: аппаратные аварии (BKIN/disable) не ждут RTOS/задач.

Ключевой инвариант измерений: I и U используются как **усреднённые по периоду PWM** (см. `docs/measurements/MEASUREMENT_ARCHITECTURE_RU.md` и DN-001 в `docs/design-notes/DN-001_MFDC_Current_Control.md`).

### 3.1 Контур управления (привязка к PWM)
- Событие “control_tick” запускается детерминированно (например, раз в период PWM).
- Порядок (идеально):
  1) получить валидные измерения (или данные прошлого цикла по политике)
  2) `measurement_core` → фильтр/диагностика
  3) `safety_supervisor` → разрешение/запрет
  4) `control_core` → output_request
  5) `pwm_hal.apply_output()`

### 3.2 Контур обмена с ТК (250 мкс, 4 кГц)
- Приём команды, валидация (`protocol_core`)
- Обновление уставки/режима
- Формирование ответа (статус, измерения, fault_flags)
- RT-механика (контракт):
  - COMX_IRQ/EXTI ISR — **только** “разбудить/notify” (без чтения FMC/process image)
  - чтение process image по FMC и валидация — только в task-контексте (slow loop)
  - при использовании FreeRTOS API из ISR — соблюдать `configMAX_SYSCALL_INTERRUPT_PRIORITY` (см. `ThirdParty/FreeRTOS/Config/FreeRTOSConfig.h`)
  - измеримые критерии PASS и бюджет времени — см. `docs/TEST_PLAN.md` и `docs/protocols/PROTOCOL_TK_ETHERCAT.md`

### 3.3 Fault path (критичный)
- Критический fault должен выключить PWM аппаратно через BKIN (асинхронно).
- ПО:
  - фиксирует fault_flags
  - переводит state_machine в FAULT
  - запрещает повторный запуск до recovery по политике

---

## 4) Тестируемость: как архитектура поддерживает SIL/HIL
### 4.1 Юнит-тесты на ПК (Host Unit)
Тестируют Core:
- `control_core`, `measurement_core`, `safety_supervisor`, `protocol_core`, `state_machine`
через фиктивные интерфейсы (mock).

### 4.2 SIL (Software-in-the-loop)
Цель: прогонять управление на “синтетических” или записанных трассах.
- Вход: набор sample-кадров (raw или физика) + команды ТК (seq/time).
- Выход: duty/state/fault_flags.
- SIL используется для:
  - регрессии алгоритмов фильтра/регулятора
  - сравнения вариантов настройки без силового стенда
  - воспроизведения бага по логам (record/replay)

Рекомендация: хранить “golden traces” в `tests/traces/` (если появятся).

### 4.3 HIL (Hardware-in-the-loop)
Цель: прогонять полную прошивку без киловатт.
- Эмуляция входов измерений (DAC/второй МК/FPGA) в тракт АЦП
- Инъекция отказов (stuck/sat/timeout/дребезг fault)
- Измерение:
  - BKIN_RAW → PWM_OUT safe
  - тайминги control_tick и выборки
- HIL — основной источник уверенности до включения силовой части.

### 4.4 On-target интеграция
- проверка SPI/DMA, TIM1, EtherCAT (COMX/FMC), RTOS (и legacy CAN-FD, если включён)
- доказательство таймингов через debug GPIO/trace

### 4.5 Power bench / system tests
- “ступени риска”: без силовой части → ограниченная мощность → эквивалент → полный режим
- обязательные E-stop/watchdog/driver-fault тесты
- отсутствие автозапуска после критического fault

---

## 5) Наблюдаемость (обязательная часть)
Минимальные debug-сигналы (должны иметь тест-пойнты):
- DBG0/DBG1 (настраиваемые; в тестах фиксировать, какие события на них выведены)
- BKIN_RAW и PWM_OUT

Метрики:
- max control time, jitter, adc latency, comms timeout counters, overrun counters

---

## 6) Границы ответственности (чтобы не размыть)
- Только `pwm_hal` имеет право писать TIM1-регистры и управлять MOE/выходами.
- Только `safety_supervisor` определяет latch/recovery и “разрешено ли варить”.
- `control_core` не принимает решений про fault/recovery — только вычисляет управление при условии “разрешено”.
- `measurement_core` не знает про PWM/режимы — только качество данных и значения.

---

## 7) Изменения архитектуры
Любое изменение модульных границ, таймингов, safety-инвариантов:
- требует обновления этого документа и `docs/PROJECT_CONTEXT.md`
- требует плана тестов (SIL/HIL/on-target) и критериев приёмки

