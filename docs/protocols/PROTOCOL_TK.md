# Протокол обмена с ТК (Источник ↔ Технологический комплекс)

Этот документ — источник правды **для профиля CAN FD** (формат кадров, тайминги, коды статуса и политика ошибок).
Целевой интерфейс взаимодействия с ТК — **EtherCAT PDO** (см. `docs/decisions/ADR-20260210-tk-interface-ethercat-comx-fmc-and-uart-pdo-emu.md`); спецификация EtherCAT PDO будет оформлена отдельным документом/разделом.

Любые изменения CAN-профиля требуют обновления этого документа и тестов.

Артефакт для сниффинга/декодирования:
- `docs/protocols/tk_protocol.dbc` — машинно‑читаемое описание (для CANalyzer/SavvyCAN/cantools и т.п.). Байтовая раскладка сигналов в DBC соответствует таблицам раскладки payload из этого документа (см. раздел 1.2 / Spec-lock).

Ограничения DBC (важно):
- DBC фиксирует *раскладку* и *масштабы* сигналов, но плохо выражает правила протокола уровня валидатора (например: «MUST=0», правила `seq`, условия допуска `ManualDuty` и т.п.).
- Каноника поведения, таймингов и правил REJECT/APPLY — **в этом документе**; DBC следует рассматривать как вспомогательный артефакт для декодирования/логов.

Примечание по терминам: далее «Источник» (контроллер) может также обозначаться как «ИСТ», «УСПФ» или «плата источника сварочного тока» (см. `docs/GLOSSARY.md`).

---

## 1) Транспорт и общие параметры
- Шина: **CAN FD** (ISO 11898-1:2015)
- CAN-ID: **Standard 11-bit ID**
- Скорости: Nominal **1 Mbit/s**, Data **2 Mbit/s**
- Payload: до **64 байт**
- Message map (CAN-ID):
  - `0x010` — `FAULT` (Critical)
  - `0x020` — `CMD_WELD` (ТК → Источник, Realtime 1 kHz)
  - `0x030` — `FB_STATUS` (Источник → ТК, Realtime 1 kHz)
  - `0x060` — `SERVICE_REQ` (Config)
  - `0x070` — `SERVICE_RESP` (Config)
- Период команд ТК: **1 мс**
- Модель обмена:
  - [x] периодическая телеметрия + команды (1 кГц)
  - [ ] запрос-ответ
  - [ ] смешанная
- Временные требования:
  - Максимальная задержка ответа источника на команду: **≤ 1 мс** (≤ 1 периода)
  - Таймаут отсутствия команд:
    - soft-timeout: **5 мс** (Draft 0.2) → controlled stop / спад `I_ref_used`
    - hard-timeout: **20 мс** (Draft 0.2) → запрет сварки + FAULT (latch по политике)

Примечание (отладка):
- При стендовой отладке без реального ТК взаимодействие по CAN может имитироваться с ПК; CAN-кадры могут передаваться как полезная нагрузка внутри PCcom4 по USB-UART (см. `docs/protocols/PCCOM4.02.md`). Тайминги 1 мс в этом режиме не гарантируются.

---

## 1.1) Единицы измерения и типы данных (Draft 0.2)

- Все значения тока в протоколе — **`int32_t` в mA** (signed).
  - Обоснование: signed нужен для корректной обработки “шума нуля” (отрицательные значения после интегратора катушки Роговского) и для запаса по переполнению при КЗ (возможны броски > 65 кА).
- Максимальный ток по системе: **50 000 А** (50 000 000 mA).

---

## 1.2) Spec-lock: сериализация и валидаторы (Draft 0.2.2)

### 1.2.1 DLC и endianness
- DLC фиксированы:
  - `0x010 FAULT` — **DLC=16**
  - `0x020 CMD_WELD` — **DLC=16**
  - `0x030 FB_STATUS` — **DLC=48**
  - `0x060 SERVICE_REQ` — **DLC=8**
  - `0x070 SERVICE_RESP` — **DLC=8**
- Endianness: все multi-byte поля (`u16/u32/i32`) кодируются как **Little-Endian (LE)**, **без исключений**, включая `SERVICE_REQ/SERVICE_RESP`.

### 1.2.2 Reserved policy
- Любые `reserved` байты/биты при передаче: **MUST=0**.
- При приёме команд:
  - `CMD_WELD` и `SERVICE_REQ`: любое `reserved != 0` ⇒ **REJECT** + `cnt_cmd_reject++`.
  - Примечание: в Draft 0.2.x поля `flags`/`crc` также считаются зарезервированными (MUST=0). Ненулевые значения трактуются как несовместимость/ошибка формирования кадра и приводят к REJECT (см. раздел 3 и 8).

### 1.2.3 Политика `seq` (u16)
`seq` — 16-битный счётчик, увеличиваемый ТК по модулю 65536. Для корректной работы при переполнении (wrap-around 65535 → 0) сравнение выполняется в кольце `u16`.

Определения:
- `last_seq` — последнее **принятое и применённое** значение `seq` (хранится на стороне Источника).
- `delta = (uint16_t)(seq - last_seq)` — смещение вперёд в кольце `u16` (0…65535).

Правила (нормативно, Draft 0.2.2):
- Первый валидный кадр после старта/ресета (`last_seq` не инициализирован):
  - **APPLY**, установить `last_seq = seq`, `SEQ_GAP_DETECTED=0`.
- Повтор (`delta == 0`) ⇒ **REJECT** (дубликат).
- Движение вперёд (включая wrap-around):
  - `delta == 1` ⇒ **APPLY** (нормальный следующий кадр).
  - `delta > 1` и `delta <= 0x7FFF` ⇒ **APPLY** + `SEQ_GAP_DETECTED=1` + `cnt_seq_gap++`.
- Скачок назад:
  - `delta > 0x7FFF` ⇒ **REJECT** (кадр “из прошлого” по отношению к `last_seq`).

Примечания:
- Порог `0x7FFF` выбран для однозначного определения направления в кольце `u16` (типичная техника “half-range”).
- При REJECT по `seq` значение `seq_applied` в `FB_STATUS/FAULT` не меняется (см. раздел 4).

Аналогичное правило применяется к `svc_seq` (u8) в `SERVICE_REQ/SERVICE_RESP` (см. раздел 8): сравнение по модулю 256, “half-range” порог `0x7F`.

### 1.2.4 Таймауты команд ТК (для тестов)
- `soft-timeout = 5 ms` ⇒ controlled stop (спад `I_ref_used` по политике)
- `hard-timeout = 20 ms` ⇒ запрет сварки + `FAULT` по политике

### 1.2.5 Константы валидатора
- `I_ref_max_mA = 50_000_000` (50 кА)
- `max_slew_rate_A_ms`:
  - диапазон: `0 … 50_000` (A/мс)
  - `0` ⇒ использовать default `max_slew_rate_default_A_ms = 5_000` (A/мс)

---

## 2) Состояния устройства (state machine)
Перечень состояний и что разрешено в каждом:
- IDLE: PWM OFF, сварка запрещена; допускается приём конфигурации/диагностика.
- ARMED: готовность к старту (условия safety OK, latch отсутствует), PWM ещё OFF.
- WELD: активный цикл сварки, PWM ON (если enable=1 и safety разрешил).
- FAULT: latched-off (PWM OFF, драйверы запрещены), ждёт recovery по политике.
- (другие): не используются в Draft 0.2.

Условия переходов:
- IDLE → ARMED: `enable=1` + валидная команда + отсутствует latch (см. `docs/SAFETY.md` / раздел 6).
- ARMED → WELD: start по технологической логике при `enable=1` и gating OK (переход в PWM ON внутри детерминизма PWM-домена).
- * → FAULT: любой HARD-FAULT / аппаратный trip / критичный fault по политике latch (см. `docs/SAFETY.md`).
- FAULT → IDLE: `fault_reset=1` (если предусмотрено) + условия recovery выполнены (см. `docs/SAFETY.md` / раздел 5).

---

## 3) Команда ТК → Источник (`CMD_WELD`, CAN-ID `0x020`)
### 3.1 Поля
- `seq` (счётчик последовательности): **u16** (Draft 0.2, монотонно увеличивается по модулю 65536)
- `mode` (запрошенный режим): **u8** (Draft 0.2)
  - `0` = IDLE
  - `1` = ARMED
  - `2` = WELD
- `enable` (разрешение сварки): 0/1
- `I_ref_cmd` (уставка тока): **int32_t**, единица **mA**
- `max_slew_rate_A_ms` (лимит dI/dt): **u16**, единица **A/мс** (**обязательное поле**)
- `fault_reset` (запрос recovery): 0/1 (применимо только в `state=FAULT` и только по политике `docs/SAFETY.md`)
- `flags` (u8): **MUST=0** (Draft 0.2.x)
- `crc` (u8): **MUST=0** (Draft 0.2.x)
- `reserved` (u8): **MUST=0**

### 3.2 Правила валидации
- Диапазоны уставок: `I_ref_cmd` в пределах `0 … I_ref_max_mA`; единица mA фиксирована.
- `max_slew_rate_A_ms` MUST присутствовать в кадре:
  - диапазон: `0 … 50_000` (A/мс)
  - `0` ⇒ использовать default `max_slew_rate_default_A_ms`
- `mode` MUST быть из перечисления Draft 0.2: `0 IDLE`, `1 ARMED`, `2 WELD`. Иное значение ⇒ REJECT + `fault_code=CMD_INVALID`.
- `enable` MUST быть `0` или `1`. Иное значение ⇒ REJECT + `fault_code=CMD_INVALID`.
- Согласованность `mode` ↔ `enable` (чтобы убрать неоднозначность):
  - Если `enable == 0`, то `mode MUST == IDLE`. Иначе ⇒ REJECT + `fault_code=CMD_INVALID`.
  - Если `mode == WELD`, то `enable MUST == 1`. (Это следует из правила выше, но фиксируется явно.)
- `fault_reset` (если `1`) допускается **только** при выполнении всех условий:
  - текущее состояние Источника `state == FAULT`;
  - `enable == 0` (запрет сварки);
  - `mode == IDLE` (запрос выхода в IDLE после recovery).
  В противном случае ⇒ REJECT + `fault_code=CMD_INVALID`.
- Недопустимые комбинации: `flags != 0` → кадр не применять (Draft 0.2.x).
- Политика `seq`:
  - что считается пропуском/повтором: повтор/скачок назад → кадр не применять
  - применять ли “старую” уставку: да, но только в пределах soft-timeout; при hard-timeout — stop/fault
- CRC/контроль целостности: для CAN FD отдельный payload CRC не используется; целостность обеспечивает CRC CAN. `crc != 0` трактуется как `CMD_INVALID` (Draft 0.2.x).

### 3.3 Пояснения к полям (семантика)
- `seq`: номер командного кадра (см. политику `seq` в разделе 1.2); используется для детекта пропусков/повторов.
- `mode`: запрошенный режим state machine (IDLE/ARMED/WELD). Фактическое состояние отражается в `FB_STATUS.state`.
- `enable`:
  - `1` — разрешение на сварку при выполнении условий safety/gating (см. `docs/SAFETY.md` / раздел 6).
  - `0` — запрет сварки; PWM OFF не позже чем через **2 периода PWM**. Controlled stop (спад `I_ref_used`) допускается, но всегда ограничен `soft-timeout/hard-timeout` политикой.
- `I_ref_cmd`: командная уставка тока. Единица mA, диапазон `0…I_ref_max_mA`.
- `max_slew_rate_A_ms`: ограничитель скорости изменения уставки (dI/dt) в **A/мс**; при значении `0` применяется default `max_slew_rate_default_A_ms`. Внутри прошивки может масштабироваться в mA/мс для расчётов, но в протоколе единица — A/мс.
- `fault_reset`: запрос на снятие latch/восстановление (применимо только в `state=FAULT` и только при выполнении условий recovery; см. `docs/SAFETY.md` / раздел 5).
- `fault_reset` (важно): `fault_reset=1` — это **запрос** на recovery, а не гарантия. Если условия recovery не выполнены, Источник **SHALL** REJECT кадр или не менять состояние (по политике `docs/SAFETY.md`), но в любом случае не включать PWM “сам по себе”.
- `flags`: зарезервировано под расширения протокола; в Draft 0.2.x MUST=0, иначе REJECT.
- `crc`: зарезервировано; в Draft 0.2.x MUST=0, иначе REJECT и причина `fault_code=CMD_INVALID`.
- `reserved*`: MUST=0; любое ненулевое значение трактуется как несовместимость/ошибка формирования кадра и ведёт к REJECT.
- Настройка коэффициентов регулятора тока (и связанных tuning-параметров) по CAN **запрещена**: команды записи/commit для таких параметров в CAN-протоколе отсутствуют. По CAN допускается только чтение (диагностика), если такие поля/кадры предусмотрены проектом. Запись/изменение tuning выполняется только через сервисное ПО по UART (PCcom), см. `docs/protocols/PCCOM4.02_PROJECT.md` / раздел 2.1.

### 3.4 Байтовая раскладка payload (`CMD_WELD`, DLC=16, LE)
| Bytes | Field | Type | Units |
|---|---|---|---|
| 0..1 | `seq` | u16 | - |
| 2 | `mode` | u8 | - |
| 3 | `enable` | u8 | - |
| 4..7 | `I_ref_cmd` | i32 | mA |
| 8..9 | `max_slew_rate_A_ms` | u16 | A/мс |
| 10 | `fault_reset` | u8 | - |
| 11 | `flags` | u8 | MUST=0 |
| 12 | `crc` | u8 | MUST=0 |
| 13 | `reserved0` | u8 | MUST=0 |
| 14..15 | `reserved1` | u16 | MUST=0 |

---

## 4) Ответ Источник → ТК (`FB_STATUS`, CAN-ID `0x030`)
### 4.1 Поля
- `seq_applied` (подтверждение seq): последнее применённое `seq`
- `state` (текущее состояние): IDLE/ARMED/WELD/FAULT
- `status_word` (битовое слово): **u16** (Draft 0.2)
  - bit0 `READY`
  - bit1 `CMD_REJECTED`
  - bit2 `COMMS_SOFT_TIMEOUT_ACTIVE`
  - bit3 `COMMS_HARD_TIMEOUT_ACTIVE`
  - bit4 `BUS_OFF_ACTIVE`
  - bit5 `ADC_INVALID`
  - bit6 `CTRL_OVERRUN`
  - bit7 `MANUAL_DUTY_ACTIVE`
  - bit8 `SEQ_GAP_DETECTED`
- `fault_word` (битовое слово): **u16** (Draft 0.2, только faults)
  - bit0 `DRIVER_FAULT`
  - bit1 `HW_TRIP`
  - bit2 `ADC_FAULT`
  - bit3 `COMMS_TIMEOUT_HARD`
  - bit4 `CTRL_OVERRUN`
  - bit5 `OVERTEMP`
- `limit_word` (битовое слово): **u16** (Draft 0.2, только limits)
  - bit0 `LIMIT_DUTY`
  - bit1 `LIMIT_DI_DT`
  - bit2 `LIMIT_BY_VS` (volt-seconds)
  - bit3 `SATURATION_SUSPECTED`
- `fault_code` (u16): enum “последней причины” (для логов/тестов), `0=NONE` (см. раздел 6); приоритет у `fault_word`/`status_word`.
- `I_ref_used` (уставка, реально поданная в контур): **int32_t**, единица **mA**
- `duty_used_permille` (опционально): фактически применённая скважность (0.1%/LSB, 0…1000); актуально для `ManualDuty` и диагностики duty-limit (см. раздел 8)
- `I_per` (средний ток за период PWM): **int32_t**, единица **mA**
- `U_per` (среднее U за период PWM): **u16**, масштаб **0.1 В/LSB** (Draft 0.2)
- `temp`/прочее: TBD
- `counters`: Draft 0.2 (минимум, u16 saturating): `cnt_cmd_reject`, `cnt_seq_gap`, `cnt_adc_fault`, `cnt_comms_fault`, `cnt_ctrl_overrun`, `cnt_log_overrun`

### 4.1.1 Пояснения к полям (семантика)

- `seq_applied`: “эхо” последней **принятой и применённой** команды (после валидации и правил `seq`). Если кадр команды отвергнут — `seq_applied` не меняется.
- `state`: фактическое состояние источника на момент формирования кадра статуса (Draft 0.2: IDLE/ARMED/WELD/FAULT).
- `status_word`: агрегированные признаки “качества” и контекста:
  - `READY`: источник готов принять команду/разрешить сварку при выполнении gating.
  - `CMD_REJECTED`: последняя команда отвергнута валидатором/правилами `seq` (см. также `cnt_cmd_reject`).
  - `COMMS_SOFT_TIMEOUT_ACTIVE`: нет валидных команд дольше `soft-timeout`, выполняется controlled stop (спад `I_ref_used`).
  - `COMMS_HARD_TIMEOUT_ACTIVE`: нет валидных команд дольше `hard-timeout`, сварка запрещена/переход в FAULT по политике.
  - `BUS_OFF_ACTIVE`: CAN в состоянии bus-off или запрещён по политике восстановления; сварка запрещена.
  - `ADC_INVALID`: измерения считаются невалидными (timeout/stuck/out-of-range по диагностике) и сварка запрещена по политике.
  - `CTRL_OVERRUN`: был overrun критического цикла (минимум stop; политика может быть latch).
  - `MANUAL_DUTY_ACTIVE`: активен сервисный режим `ManualDuty` (см. раздел 8).
  - `SEQ_GAP_DETECTED`: обнаружен пропуск `seq` (применён новый кадр, но с gap); отражается счётчиком `cnt_seq_gap`.
- `fault_word`: активные/защёлкнутые faults (класс C0/C1 по `docs/SAFETY.md`), которые запрещают сварку и требуют recovery по политике.
- `limit_word`: причины ограничения (LIMIT) без latch (напр. volt-seconds/di/dt/duty limit); важно для устойчивости и диагностики, но само по себе не является “аппаратной аварией”.
- `fault_code`: enum “последней причины” (см. раздел 6), `0=NONE`; приоритет у `fault_word`/`status_word`.
- `I_ref_used`: уставка, реально поданная в контур (после gating/лимитов/спадов по timeout), **int32_t**, **mA**.
- `duty_used_permille`: фактически применённая скважность (после ограничителей/slew-rate), **0.1%/LSB**.
- `I_per`, `U_per`: агрегированные величины **за период PWM** (см. `docs/measurements/MEASUREMENT_ARCHITECTURE_RU.md`), **mA** (int32_t) и **0.1 В/LSB** (u16).
- `reserved0`: MUST=0 (зарезервировано под будущие расширения; в SW-0 не используется).
- `reserved_power`: MUST=0 (поле мощности не используется в плате; резерв под совместимость фиксированного DLC).
- `counters`: saturating u16 (накапливаемые счётчики для диагностики/тестов):
  - `cnt_cmd_reject`: сколько кадров команды отвергнуто валидатором.
  - `cnt_seq_gap`: сколько раз применён кадр с gap по `seq`.
  - `cnt_adc_fault`: сколько раз фиксировалась невалидность измерений (ADC timeout/stuck/out-of-range).
  - `cnt_comms_fault`: сколько раз входили в soft/hard-timeout и/или bus-off обработку.
  - `cnt_ctrl_overrun`: сколько раз был overrun критического цикла.
  - `cnt_log_overrun`: сколько раз логирование/очереди не успевали (дроп/переполнение).
- `reserved_tail`: MUST=0 (резерв).
- `temp`: резерв под температуры/питания и др. “медленные” каналы (TBD).

#### 4.1.1.1 Нормативная семантика битовых слов (Draft 0.2.2, SW-0)
Ниже — “что означает бит” и *когда* он должен устанавливаться/сбрасываться. Это сделано, чтобы ТК мог однозначно интерпретировать флаги, а тесты могли быть детерминированными.

`status_word` (u16, не latched, если не оговорено иначе):
- bit0 `READY`: 1, если Источник готов принять/выполнить команду на сварку при `enable=1` и `mode=WELD` (gating OK). В `state=FAULT` MUST=0.
- bit1 `CMD_REJECTED`: 1, если **последний** принятый на вход `CMD_WELD` был отвергнут валидатором (формат/диапазон/`seq`/reserved). Сбрасывается при **следующем** успешно применённом `CMD_WELD`.
- bit2 `COMMS_SOFT_TIMEOUT_ACTIVE`: 1, если активен soft-timeout (нет валидных `CMD_WELD` дольше `soft-timeout`). Сбрасывается при получении валидного `CMD_WELD`.
- bit3 `COMMS_HARD_TIMEOUT_ACTIVE`: 1, если активен hard-timeout (нет валидных `CMD_WELD` дольше `hard-timeout`). Сбрасывается только после восстановления связи и выполнения политики выхода из hard-timeout (см. раздел 5 и `docs/SAFETY.md`).
- bit4 `BUS_OFF_ACTIVE`: 1, если CAN в bus-off или интерфейс CAN запрещён политикой восстановления. Сбрасывается после успешного восстановления CAN (см. раздел 5).
- bit5 `ADC_INVALID`: 1, если измерения объявлены невалидными диагностикой (timeout/stuck/out-of-range/CRC/и т.п.) и сварка должна быть запрещена политикой. Сбрасывается, когда измерения снова признаны валидными (и политика разрешает продолжение).
- bit6 `CTRL_OVERRUN`: 1, если был overrun критического цикла управления, относящийся к текущему отчётному окну `FB_STATUS`. Минимум: controlled stop/запрет сварки (см. раздел 5). Если политика делает overrun latch-fault, то дополнительно выставляется `fault_word.CTRL_OVERRUN`.
- bit7 `MANUAL_DUTY_ACTIVE`: 1, если активен сервисный режим `ManualDuty` (см. раздел 8). В этом режиме сварка штатным контуром запрещена.
- bit8 `SEQ_GAP_DETECTED`: 1, если **последний применённый** `CMD_WELD` имел gap по `seq` (см. 1.2.3) и был применён как “вперёд с пропуском”. Сбрасывается при применении кадра с `delta==1`.

`fault_word` (u16, faults, latch по политике `docs/SAFETY.md`):
- bit0 `DRIVER_FAULT`: fault драйвера/силовой части (например, сигнал FAULT от драйвера). Требует recovery.
- bit1 `HW_TRIP`: аппаратный trip/защита (например, BKIN/компаратор/аппаратный shutdown-path). Требует recovery, сварка запрещена.
- bit2 `ADC_FAULT`: измерительный fault (системная неработоспособность измерений: timeout/CRC/stuck/out-of-range, если политика относит это к fault-классу). Может сопровождаться `status_word.ADC_INVALID=1`.
- bit3 `COMMS_TIMEOUT_HARD`: hard-timeout по командам (см. раздел 5). Это fault-событие; сварка запрещена до recovery по политике.
- bit4 `CTRL_OVERRUN`: latched-fault по overrun (если политика так настроена). Если политика “не latch”, этот бит MUST оставаться 0, а событие отражать в `status_word.CTRL_OVERRUN` + `cnt_ctrl_overrun`.
- bit5 `OVERTEMP`: перегрев по политике. Требует recovery.

`limit_word` (u16, limits, не latch):
- bit0 `LIMIT_DUTY`: активен лимитер по скважности (duty ограничена сверху политикой/лимитами).
- bit1 `LIMIT_DI_DT`: активен лимитер по скорости изменения тока/уставки (dI/dt, slew-rate).
- bit2 `LIMIT_BY_VS`: активен лимитер по volt-seconds (ограничение по интегралу напряжения/времени, если применимо).
- bit3 `SATURATION_SUSPECTED`: подозрение на насыщение/некорректность измерения (диагностический limit-флаг). Не является fault сам по себе, но может быть использован ТК для деградации режима/остановки.

Инварианты интерпретации (для ТК):
- `fault_word != 0` ⇒ `READY` MUST=0 и сварка запрещена (даже если `enable=1`).
- `COMMS_HARD_TIMEOUT_ACTIVE=1` ⇒ сварка запрещена; как минимум `fault_word.COMMS_TIMEOUT_HARD` должен отражать hard-timeout по политике.
- `MANUAL_DUTY_ACTIVE=1` ⇒ сварка штатным контуром запрещена; `duty_used_permille` отражает ручную/фактически применённую скважность (если реализовано).

### 4.1.2 Байтовая раскладка payload (`FB_STATUS`, DLC=48, LE)
| Bytes | Field | Type | Units |
|---|---|---|---|
| 0..1 | `seq_applied` | u16 | - |
| 2 | `state` | u8 | - |
| 3 | `reserved0` | u8 | MUST=0 |
| 4..5 | `status_word` | u16 | - |
| 6..7 | `fault_word` | u16 | - |
| 8..9 | `limit_word` | u16 | - |
| 10..11 | `fault_code` | u16 | - |
| 12..15 | `I_ref_used` | i32 | mA |
| 16..17 | `duty_used_permille` | u16 | permille |
| 18..21 | `I_per` | i32 | mA |
| 22..23 | `U_per` | u16 | 0.1 В |
| 24..25 | `reserved_power` | u16 | MUST=0 |
| 26..27 | `cnt_cmd_reject` | u16 | - |
| 28..29 | `cnt_seq_gap` | u16 | - |
| 30..31 | `cnt_adc_fault` | u16 | - |
| 32..33 | `cnt_comms_fault` | u16 | - |
| 34..35 | `cnt_ctrl_overrun` | u16 | - |
| 36..37 | `cnt_log_overrun` | u16 | - |
| 38..47 | `reserved_tail` | u8[10] | MUST=0 |

### 4.2 Правила формирования
- Частота ответа: **1 кГц** (синхронно с командным доменом)
- Что отправляется в FAULT: `state=FAULT`, актуальные fault/limit слова, диагностические счётчики, последняя причина.
- Стабильность значений: в статусе отдавать агрегированные по периоду значения (`I_per`, `U_per`), а RAW — только в отдельном режиме/логе (если нужен).

### 4.3 Сообщение `FAULT` (CAN-ID `0x010`, DLC=16, LE)

Назначение: немедленное уведомление о критичной аварии (в дополнение к `FB_STATUS` 1 кГц).

Поля:
- `seq_applied` (u16)
- `state` (u8, типично `FAULT`)
- `reserved0` (u8, MUST=0)
- `fault_word` (u16)
- `fault_code` (u16)
- `fault_time_ms` (u32, ms since boot; `0` если нет timebase)
- `fault_context` (u32, Draft 0.2.2 = 0)

#### 4.3.1 Пояснения к полям (семантика)
- `seq_applied`: последнее применённое `seq` из `CMD_WELD` на момент формирования аварии (для корреляции “какая команда была активна”).
- `state`: состояние источника (ожидаемо `FAULT`).
- `reserved0`: MUST=0.
- `fault_word`: битовая маска активных/защёлкнутых faults (см. `FB_STATUS.fault_word`).
- `fault_code`: enum “последней причины” (см. раздел 6), `0=NONE`; используется для удобства логов/тестов.
- `fault_time_ms`: отметка времени (мс с момента старта); если timebase не реализован — `0`.
- `fault_context`: расширенный контекст/подпричина (Draft 0.2.2 = 0).

Байтовая раскладка payload (`FAULT`, DLC=16, LE):
| Bytes | Field | Type | Units |
|---|---|---|---|
| 0..1 | `seq_applied` | u16 | - |
| 2 | `state` | u8 | - |
| 3 | `reserved0` | u8 | MUST=0 |
| 4..5 | `fault_word` | u16 | - |
| 6..7 | `fault_code` | u16 | - |
| 8..11 | `fault_time_ms` | u32 | ms |
| 12..15 | `fault_context` | u32 | - |

---

## 5) Политика ошибок и таймаутов
- Потеря команд:
  - soft-timeout → controlled stop (спад `I_ref_used`) + status flag
  - hard-timeout → запрет сварки + FAULT (по политике latch)
- Сервисный режим `ManualDuty` (если включён): отсутствие сервис-команд/keepalive по интерфейсу активации > **20 мс** ⇒ запрет сварки + переход в safe state (см. раздел 8 и `docs/design-notes/DN-002_MFDC_ManualDuty_Service_Mode.md`)
- Ошибка CRC/кадра: кадр не применять; счётчик + status flag
- Повторы/пропуски seq: повтор/скачок назад — не применять; пропуск — применить новый, установить `SEQ_GAP_DETECTED` и увеличить `cnt_seq_gap`
- Bus-off/ошибки линии: **без ABOM** (Draft 0.2).
  - При событии Bus-Off: источник прекращает передачу, запрещает сварку (gating) и формирует `BUS_OFF_ACTIVE`.
  - Восстановление: программная переинициализация CAN не чаще, чем раз в `T_busoff_backoff_ms` (Draft 0.2: 250 мс, диапазон 100–500 мс).
  - При повторяющихся Bus-Off: эскалация в fault по политике (TBD).
- Несовместимая конфигурация/режим: кадр не применять; status flag + `fault_code=INCOMPATIBLE_MODE`.

---

## 6) Коды ошибок (fault_code) и битовые слова (`status_word`/`fault_word`/`limit_word`)
`fault_code` — “последняя причина” для удобства логов/тестов; основная истина остаётся в `fault_word`.

Минимальная каноника SW-0 (Draft 0.2.2, u16):
| Code | Name |
|---:|---|
| 0 | `NONE` |
| 1 | `DRIVER_FAULT` |
| 2 | `HW_TRIP` |
| 3 | `ADC_SPI_TIMEOUT` |
| 4 | `ADC_RANGE` |
| 5 | `ADC_STUCK` |
| 6 | `COMMS_TIMEOUT_HARD` |
| 7 | `COMMS_TIMEOUT_SOFT` |
| 8 | `BUS_OFF` |
| 9 | `CMD_INVALID` |
| 10 | `CTRL_OVERRUN` |
| 11 | `OVERTEMP` |
| 12 | `INCOMPATIBLE_MODE` |
| 13 | `INTERNAL_ERR` |

### 6.0 Пояснение: “код” vs “бит”
Чтобы избежать путаницы:
- `fault_word` — *факты* (fault-события), которые активны/защёлкнуты по политике (`docs/SAFETY.md`). Это основной источник правды для запрета сварки.
- `status_word` — контекст/качество связи/диагностика (многие флаги не latched).
- `fault_code` — “последняя причина” для логов/тестов: одно число, которое помогает быстро понять, *почему* Источник сейчас (или только что) ограничил/запретил сварку или отвергнул команды.

### 6.1 Правила формирования `fault_code` (Draft 0.2.2, SW-0)
`fault_code` предназначен для удобства логов/тестов и **не** заменяет `fault_word`/`status_word`. Чтобы ТК мог детерминированно использовать `fault_code` в логах, фиксируется следующая политика формирования (SW-0):

1) Если `fault_word != 0`, то `fault_code` **SHALL** соответствовать одному из активных fault-событий (приоритет сверху вниз):
   1. `HW_TRIP`
   2. `DRIVER_FAULT`
   3. `OVERTEMP`
   4. `ADC_SPI_TIMEOUT` / `ADC_RANGE` / `ADC_STUCK` (в зависимости от первопричины, если различается диагностикой)
   5. `COMMS_TIMEOUT_HARD`
   6. `CTRL_OVERRUN`
2) Иначе (то есть `fault_word == 0`):
   - если `status_word.BUS_OFF_ACTIVE=1` ⇒ `fault_code = BUS_OFF`;
   - else если `status_word.COMMS_HARD_TIMEOUT_ACTIVE=1` ⇒ `fault_code = COMMS_TIMEOUT_HARD`;
   - else если `status_word.COMMS_SOFT_TIMEOUT_ACTIVE=1` ⇒ `fault_code = COMMS_TIMEOUT_SOFT`;
   - else если `status_word.CMD_REJECTED=1` ⇒ `fault_code = CMD_INVALID`;
   - else ⇒ `fault_code = NONE`.

Коды `INCOMPATIBLE_MODE` и `INTERNAL_ERR` используются для редких случаев:
- `INCOMPATIBLE_MODE`: команда *синтаксически* корректна, но несовместима с текущей конфигурацией/режимом/политикой (например, попытка `mode=WELD` в режиме `ManualDuty` или запрос режима, отключённого сборкой).
- `INTERNAL_ERR`: внутренняя ошибка (например, ресурс/подсистема недоступны), когда нельзя корректно классифицировать причину другим кодом.

### 6.2 Подробные пояснения по кодам `fault_code` (что именно означает и когда выставляется)
Ниже — “человеческая” расшифровка каждого кода и связь с битовыми словами. Это нужно, чтобы:
- на стороне ТК не гадать “что именно сломалось”;
- тесты могли проверять ожидаемую причину без доступа к внутренним логам прошивки.

0) `NONE`
- Значение по умолчанию, когда нет активных faults/таймаутов/bus-off и последняя команда не была отвергнута.

1) `DRIVER_FAULT`
- Причина: fault сигнализируется силовым драйвером/драйверной логикой (в т.ч. внешним входом fault).
- Ожидаемые отражения:
  - `fault_word.DRIVER_FAULT=1` (по политике latch);
  - `status_word.READY=0`.

2) `HW_TRIP`
- Причина: аппаратный trip/аппаратный shutdown-path (например BKIN/компаратор/аппаратная защита).
- Ожидаемые отражения:
  - `fault_word.HW_TRIP=1` (по политике latch);
  - `status_word.READY=0`.

3) `ADC_SPI_TIMEOUT`
- Причина: таймаут обмена с АЦП/датчиками по SPI (нет данных в ожидаемое окно / timeout диагностикой).
- Ожидаемые отражения:
  - минимум `status_word.ADC_INVALID=1` (измерения невалидны и сварка запрещена политикой);
  - если политика относит это к fault-классу: `fault_word.ADC_FAULT=1`.

4) `ADC_RANGE`
- Причина: измерение/канал вне допустимого диапазона (out-of-range) по диагностике.
- Ожидаемые отражения:
  - минимум `status_word.ADC_INVALID=1`;
  - опционально (по политике): `fault_word.ADC_FAULT=1`.

5) `ADC_STUCK`
- Причина: “залипание” измерения (stuck) по диагностике (например, значение не меняется дольше допустимого окна или не соответствует физике).
- Ожидаемые отражения:
  - минимум `status_word.ADC_INVALID=1`;
  - опционально (по политике): `fault_word.ADC_FAULT=1`.

6) `COMMS_TIMEOUT_HARD`
- Причина: истёк `hard-timeout` отсутствия валидных `CMD_WELD` (см. раздел 5).
- Ожидаемые отражения:
  - `status_word.COMMS_HARD_TIMEOUT_ACTIVE=1`;
  - `fault_word.COMMS_TIMEOUT_HARD=1` (fault-событие по политике);
  - `status_word.READY=0`.

7) `COMMS_TIMEOUT_SOFT`
- Причина: истёк `soft-timeout` отсутствия валидных `CMD_WELD` (controlled stop / спад `I_ref_used`, см. раздел 5).
- Ожидаемые отражения:
  - `status_word.COMMS_SOFT_TIMEOUT_ACTIVE=1`;
  - `status_word.READY=0` (сварка запрещена/гасится политикой).

8) `BUS_OFF`
- Причина: CAN bus-off (или интерфейс CAN запрещён политикой восстановления).
- Ожидаемые отражения:
  - `status_word.BUS_OFF_ACTIVE=1`;
  - `status_word.READY=0`.

9) `CMD_INVALID`
- Причина: последняя команда `CMD_WELD` отвергнута валидатором по формату/диапазонам/`seq`/reserved.
- Ожидаемые отражения:
  - `status_word.CMD_REJECTED=1`;
  - `cnt_cmd_reject` увеличивается;
  - `seq_applied` НЕ меняется.

10) `CTRL_OVERRUN`
- Причина: overrun критического цикла управления/обмена (см. раздел 5 и `status_word.CTRL_OVERRUN`).
- Ожидаемые отражения:
  - `status_word.CTRL_OVERRUN=1` и `cnt_ctrl_overrun` увеличивается;
  - если политика делает это latch-fault: `fault_word.CTRL_OVERRUN=1`.

11) `OVERTEMP`
- Причина: перегрев по политике (температура/датчик/порог).
- Ожидаемые отражения:
  - `fault_word.OVERTEMP=1` (по политике latch);
  - `status_word.READY=0`.

12) `INCOMPATIBLE_MODE`
- Причина: команда/операция синтаксически корректна, но несовместима с текущим состоянием/режимом/политикой.
- Типичные примеры (SW-0):
  - попытка `CMD_WELD.mode=WELD` при активном `ManualDuty`;
  - попытка включить сервисную операцию не в `state=IDLE` (см. раздел 8.2).
- Ожидаемые отражения:
  - для `CMD_WELD`: `status_word.CMD_REJECTED=1`, `cnt_cmd_reject++`;
  - для `SERVICE_REQ`: `SERVICE_RESP.svc_status=NOT_ALLOWED` (если `SERVICE_RESP` реализован).

13) `INTERNAL_ERR`
- Причина: внутренняя ошибка (нехватка ресурса/невозможность обслужить запрос/неожиданное состояние), когда корректнее поставить общий код, чем ошибочно “притянуть” частный.
- Ожидаемые отражения:
  - может сопровождаться `fault_word` (если политика классифицирует как fault) или только `fault_code` для логов; конкретика определяется `docs/SAFETY.md`.

---

## 7) Тестовые сценарии протокола (обязательный минимум)
- Нормальный цикл 1 мс: последовательные `seq`, `seq_applied` догоняет, статус стабилен.
- Потеря команд: soft-timeout (5 мс) → controlled stop; hard-timeout (20 мс) → запрет сварки + FAULT (по политике).
- Burst невалидных кадров/format errors: серия (бурст) подряд идущих командных кадров, которые отвергаются валидатором/правилами протокола (например: неверный CAN-ID, недопустимые `flags != 0`, уставка вне допустимого диапазона, нарушение правил `seq` (повтор/скачок назад), некорректные зарезервированные поля). Ожидаемое поведение: кадры не применяются, растёт `cnt_cmd_reject`, сварка не разрешается/гасится по политике.
- Повторы/пропуски `seq`: повтор/скачок назад — reject; пропуск — применить новый и отразить в counters/status.
- Bus-off: запрет сварки + молчание; recovery только после backoff; отсутствие “спама”.
- FAULT → отчёт → recovery: `state=FAULT`, потом `fault_reset=1` при выполнении условий → возврат в IDLE.

---

## 8) Сервисные команды (опционально): режим `ManualDuty`

Назначение: стендовая отладка ШИМ/силовой части через ручную скважность при сохранении safety-инвариантов (см. `docs/design-notes/DN-002_MFDC_ManualDuty_Service_Mode.md`).

### 8.1. Транспорт

В Draft 0.2 сервисный домен передаётся отдельными сообщениями `SERVICE_REQ`/`SERVICE_RESP` и не пересекается с 1 кГц доменом:

- `SERVICE_REQ (0x060)` — сервис-команды/запросы (в т.ч. `ManualDuty`)
- `SERVICE_RESP (0x070)` — сервисная телеметрия/ответы (опционально)

Примечание: несмотря на CAN FD, формат `ManualDuty` ниже задан как DLC=8 (в рамках payload CAN FD).

### 8.2. Правила допуска (gating)

Источник **SHALL** принимать сервисные команды `ManualDuty` только при выполнении всех условий:
- `state = IDLE` (сварка запрещена, PWM OFF);
- активных latch/fault, запрещающих запуск, нет (по политике safe state);
- команда валидна по формату и диапазонам.

При любом fault, приводящем к safe state, источник **SHALL** немедленно отключить ШИМ и выйти из `ManualDuty` (по политике аварий).

### 8.3. Формат `SERVICE_REQ` для `ManualDuty` (DLC=8, CAN FD)

`SERVICE_REQ` (Tx: сервис → источник), payload 8 байт:

- `byte0`: `svc_seq` (u8) — счётчик сервиса (монотонно увеличивается).
- `byte1`: `svc_op` (u8):
  - `0x00` — `KEEPALIVE`
  - `0x01` — `ENABLE`
  - `0x02` — `DISABLE`
  - `0x03` — `SET_DUTY`
- `byte2..3`: `duty_target_permille` (u16, **LE**), 0…1000 (0.1%/LSB). Для `ManualDuty` диапазон применения: **100…500** (10–50%); иначе REJECT.
- `byte4..5`: `slew_rate_permille_per_period` (u16, **LE**), ограничитель изменения скважности “на период ШИМ” в единицах 0.1%/период:
  - 0 ⇒ использовать default **2‰/период**
  - допустимый диапазон: **1…10‰/период**
  - иначе REJECT
- `byte6`: `flags` (u8): Draft 0.2.2 = **0** (MUST=0).
- `byte7`: `reserved` (=0, MUST=0).

#### 8.3.1 Пояснения к полям (семантика)
- `svc_seq`: счётчик сервисных команд; используется для диагностики/корреляции ответов.
- `svc_op`: операция сервиса (`KEEPALIVE/ENABLE/DISABLE/SET_DUTY`).
- `duty_target_permille`: целевая скважность в промилле (0.1%/LSB); для `ManualDuty` применимый диапазон **100…500** (10–50%), иначе REJECT.
- `slew_rate_permille_per_period`: ограничитель изменения скважности “на период ШИМ” (0.1%/период); `0` означает “использовать default 2‰/период”; значения вне диапазона **1…10‰/период** ⇒ REJECT.
- `flags`/`reserved`: MUST=0; любое ненулевое значение ⇒ REJECT + `cnt_cmd_reject++`.

#### 8.3.1.1 Подробная семантика `svc_op` (что делает каждая операция)
`SERVICE_REQ` используется **только** для сервисного режима `ManualDuty` (см. 8.1/8.2). Все операции ниже обрабатываются при выполнении gating (см. 8.2). Если gating не выполнен — операция не применяется.

Общее для всех `svc_op`:
- Любой **валидный** `SERVICE_REQ` (формат + reserved=0 + `svc_seq` по политике) в активном `ManualDuty` считается “связью” и обновляет таймер `age_ms` (см. 8.4/8.5).
- При REJECT из-за формата/зарезервированных полей/`svc_seq` рекомендуется возвращать `svc_status=REJECTED` (если `SERVICE_RESP` реализован).

`0x00 KEEPALIVE`
- Назначение: “пинг” для поддержания “связи” и продления таймаута 20 мс, без изменения состояния.
- Параметры:
  - `duty_target_permille` и `slew_rate_permille_per_period` игнорируются (рекомендуется передавать 0).
- Ожидаемая реакция:
  - если `ManualDuty` активен: продлить связь, `svc_status=OK`;
  - если `ManualDuty` не активен: `svc_status=NOT_ALLOWED` (по желанию; либо `OK` без эффекта, но это хуже для диагностики).

`0x01 ENABLE`
- Назначение: запрос включить режим `ManualDuty` (вход в сервисный режим).
- Обязательные условия (gating):
  - `state MUST == IDLE` и PWM OFF;
  - отсутствуют active latch/fault, запрещающие запуск (по политике safe state).
- Параметры:
  - при `ENABLE` допускается передать начальные `duty_target_permille`/`slew_rate_permille_per_period` (опционально). Если переданы, они валидируются по тем же правилам, что и для `SET_DUTY`.
- Ожидаемая реакция:
  - при успехе: `ManualDuty` становится активным, `svc_status=OK`, `SERVICE_RESP.flags.bit0=1`;
  - при запрете по gating: `svc_status=NOT_ALLOWED`.

`0x02 DISABLE`
- Назначение: запрос выключить `ManualDuty` и вернуть safe state (PWM OFF).
- Параметры:
  - все параметры могут быть 0 и игнорируются.
- Ожидаемая реакция:
  - при успехе: PWM OFF, `ManualDuty` не активен, `svc_status=OK`, `SERVICE_RESP.flags.bit0=0`.

`0x03 SET_DUTY`
- Назначение: изменить целевую скважность в активном `ManualDuty`.
- Условия:
  - `ManualDuty` должен быть активен (иначе `svc_status=NOT_ALLOWED`).
- Параметры:
  - `duty_target_permille`: целевая скважность (0.1%/LSB). Для `ManualDuty` применяется диапазон **100…500** (10–50%); иначе `INVALID_RANGE`.
  - `slew_rate_permille_per_period`: ограничение изменения скважности “на период PWM” (0.1%/период):
    - `0` ⇒ default **2‰/период**
    - `1…10` ⇒ допустимо
    - иначе `INVALID_RANGE`.
- Ожидаемая реакция:
  - при успехе: скважность стремится к `duty_target_permille` с ограничением по `slew_rate_permille_per_period`, `svc_status=OK`.

#### 8.3.2 Политика `svc_seq` (u8)
`svc_seq` сравнивается по модулю 256 (wrap-around 255 → 0) по тем же правилам “half-range”, что и `seq` (см. 1.2.3), только с порогом `0x7F`:
- первый валидный `SERVICE_REQ` после входа в сервисный режим: APPLY, `last_svc_seq = svc_seq`;
- повтор (`delta==0`) ⇒ REJECT;
- движение вперёд: `delta==1` нормально, `delta>1 && delta<=0x7F` допускается (gap) и может инкрементировать диагностический счётчик (если реализован);
- скачок назад (`delta>0x7F`) ⇒ REJECT.

### 8.4. Семантика “связи” и таймаут 20 мс

В режиме `ManualDuty` источник **SHALL** считать “связью” приход любого **валидного** `SERVICE_REQ` (любой `svc_op`, включая `KEEPALIVE`).

Если в течение **20 мс** не пришло ни одного валидного `SERVICE_REQ` по интерфейсу, через который режим `ManualDuty` был включён, источник **SHALL** перейти в safe state и отключить `ManualDuty`.

### 8.5. Телеметрия (минимум)

Источник **SHOULD** отражать активность `ManualDuty` в стандартной телеметрии:
- `status_word`: бит `MANUAL_DUTY_ACTIVE` (Draft 0.2: bit7).
- (опционально) `duty_used_permille` (u16, 0.1%/LSB) — фактически применённая скважность.

Формат `SERVICE_RESP` (CAN-ID `0x070`, DLC=8, LE):
- `byte0`: `svc_seq_echo` (u8)
- `byte1`: `svc_status` (u8): `0 OK`, `1 REJECTED`, `2 NOT_ALLOWED`, `3 INVALID_RANGE`, `4 TIMEOUT_EXIT`, `5 INTERNAL_ERR`
- `byte2`: `state` (u8): `0 IDLE`, `1 ARMED`, `2 WELD`, `3 FAULT`
- `byte3`: `flags` (u8): bit0 `MANUAL_DUTY_ACTIVE`, остальные MUST=0
- `byte4..5`: `duty_used_permille` (u16, LE), 0…1000; если неактуально — `0`
- `byte6..7`: `age_ms` (u16, LE) — возраст (мс) с последнего валидного `SERVICE_REQ`, saturating

#### 8.5.1 Пояснения к полям (семантика)
- `svc_seq_echo`: эхо `svc_seq` последнего обработанного `SERVICE_REQ` (для связи “запрос-ответ” в логах).
- `svc_status`: результат обработки последнего сервиса:
  - `OK` — команда применена/принята;
  - `REJECTED` — отвергнуто валидатором/зарезервированными полями;
  - `NOT_ALLOWED` — запрещено политикой (например, не `IDLE`, активен fault/latch);
  - `INVALID_RANGE` — параметр(ы) вне допустимого диапазона;
  - `TIMEOUT_EXIT` — выход из `ManualDuty` по таймауту связи;
  - `INTERNAL_ERR` — внутренняя ошибка (например, состояние/ресурс недоступны).
- `state`: текущее состояние источника.
- `flags`: bit0 `MANUAL_DUTY_ACTIVE` = активен ли `ManualDuty`; остальные MUST=0.
- `duty_used_permille`: фактически применённая скважность (если неактуально — `0`).
- `age_ms`: возраст (мс) с последнего валидного `SERVICE_REQ` по интерфейсу активации, saturating; удобен для диагностики “связь жива”.
