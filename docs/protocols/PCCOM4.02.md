# PCCOM 4.02 — спецификация протокола (embedded-friendly)

Документ: «Спецификация протокола PCcom 4.02», ЗАО «Диаконт», Санкт‑Петербург, 10.06.2014.

Цель этого файла — дать достаточно информации, чтобы реализовать совместимый стек PCcom 4.02 в любом embedded‑проекте (UART/RS‑485/UDP и т.п.).

## 1. Область применения и уровень

- PCcom 4.02 относится к прикладному уровню (уровень 7 OSI).
- Предполагаемые физические интерфейсы: асинхронные последовательные линии (RS‑232/RS‑485/RS‑422) и Ethernet UDP/IP.

## 2. Термины

- **Кадр** — единица обмена PCcom 4.02 на линии/в датаграмме.
- **Ведущее устройство (ВУ)** — инициатор запросов (обычно УК/ПУ).
- **Подчинённое устройство (ПУ)** — отвечает на запросы (обычно БУ/УП/ПА).

## 3. Адресация

- Адрес — 1 байт (0…255).
- Максимум адресуемых устройств: до 255.
- В PCcom4 поле **адрес отправителя** — источник кадра, **адрес получателя** — назначение кадра (в ответе адреса меняются местами по смыслу «источник/назначение»).

> Спецификация 4.02 не описывает «broadcast»/специальные адреса. Если в вашей системе используются специальные адреса (например, 0x00), их семантика должна быть определена проектом.

## 4. Формат кадра

### 4.1. Байтовое представление на линии

На линии/в потоке байт кадр имеет вид:

```
----------+------------------------------+
| PREAMBLE | FRAME (length bytes)        |
|  0xFF    | начинается с поля Length    |
| 1 байт   | 8..255 байт                |
----------+------------------------------+
```

`PREAMBLE` вставляется перед каждым кадром и **не является однозначным признаком начала кадра** (0xFF может встречаться и внутри полезных данных).

Поле `Length` — «полное количество байт в кадре». Из рисунка 4.1 следует, что:

- **длина кадра на линии**: 9…256 байт (включая `PREAMBLE` 1 байт);
- **максимальная длина поля `Data`**: 247 байт;
- CRC16: 2 байта.

Чтобы кадр был реализуемым и самосогласованным, далее используется практическая интерпретация, совместимая с рисунком 4.1:

- `Length` = длина `FRAME` **без** `PREAMBLE`, т.е. количество байт от `Length` до `CRC16` включительно.
- Тогда на линии общее число байт = `1 + Length`.
- Диапазон `Length`: 8…255.

Если ваш контрагент интерпретирует `Length` иначе (например, включая `PREAMBLE`), согласуйте это отдельно: спецификация 4.02 формально не фиксирует, входит ли `PREAMBLE` в «кадр» для поля `Length`.

### 4.2. Структура FRAME

`FRAME` состоит из следующих полей (в указанном порядке):

| Поле | Размер | Описание |
|---|---:|---|
| `Length` | 1 | Полное количество байт в `FRAME`. |
| `DstAddr` | 1 | Адрес получателя (назначение кадра). |
| `SrcAddr` | 1 | Адрес отправителя (источник кадра). |
| `Type` | 1 | Тип кадра (команда/ответ). |
| `Node` | 1 | Узел (идентификатор группы команд). |
| `Op` | 1 | Операция (идентификатор команды в узле). |
| `Data` | 0…247 | Необязательные данные переменной длины. |
| `CRC16` | 2 | 16‑битная контрольная сумма. |

Минимальная длина `FRAME` (при пустом `Data`) = 1+1+1+1+1+1+2 = **8 байт**.

Длина `Data` вычисляется как:

```
DataLen = Length - 8
```

### 4.3. Порядок байтов CRC16

Спецификация говорит: «CRC‑16 IBM, используемый в Modbus».

Это соответствует **Modbus RTU CRC16**:

- полином: 0xA001 (реверс 0x8005),
- начальное значение: 0xFFFF,
- побитовая обработка LSB-first,
- без XOR‑out (классический Modbus CRC).

Порядок байтов CRC в кадре PCcom 4.02 спецификацией не расписан. Для совместимости с «CRC‑16 IBM, используемый в Modbus» рекомендуется хранить/передавать CRC как в Modbus RTU:

```
CRC16 = [CRC_LO][CRC_HI]
```

### 4.4. Алгоритм вычисления CRC16

- CRC считается по всем байтам `FRAME`, **кроме `PREAMBLE`**.
- При расчёте два байта поля `CRC16` приравниваются к 0.

Псевдокод проверки:

```
rx_crc = FRAME[-2] | (FRAME[-1] << 8)          // если CRC_LO,CRC_HI
FRAME[-2] = 0
FRAME[-1] = 0
calc_crc = modbus_crc16(FRAME[0 : Length])
ok = (calc_crc == rx_crc)
```

## 5. Типы кадров

Есть 2 группы кадров: **команды** и **ответы**.

### 5.1. Команды (Type)

| Код | Название | Семантика |
|---:|---|---|
| `0x01` | Чтение данных | Запрос произвольных данных. Ответ обязателен. Поле `Data` отсутствует. |
| `0x02` | Сообщение | Информирование об изменении данных. Ответ не требуется. |
| `0x03` | Запись данных | Запись произвольных данных. Ответ обязателен. Поле `Data` содержит данные для записи. |

### 5.2. Ответы (Type)

| Код | Название | Когда используется |
|---:|---|---|
| `0x00` | Неизвестная команда | Получатель не распознал команду (`Node`,`Op`). |
| `0x04` | Чтение успешно | Ответ на `0x01`. Поле `Data` обязательно. |
| `0x05` | Запись успешна | Ответ на `0x03`. Поле `Data` обязательно. |
| `0x06` | Команда принята | Ответ на `0x01`/`0x03`, если выполнение длительное. |
| `0x07` | Ошибка чтения | Ответ на `0x01`, если чтение невозможно. |
| `0x08` | Ошибка записи | Ответ на `0x03`, если запись невозможна. |

## 6. Правила обмена (транзакции)

### 6.1. Сообщение (Type = 0x02)

- Отправитель шлёт «Сообщение».
- Получатель **не отвечает**.

### 6.2. Чтение данных (Type = 0x01)

Запрос:

- `Type=0x01`
- `Data` отсутствует (`DataLen=0`)

Ответ:

- если успешно: `Type=0x04` и `Data` **обязательно присутствует**;
- если команда неизвестна: `Type=0x00`;
- если ошибка чтения: `Type=0x07`.

### 6.3. Запись данных (Type = 0x03)

Запрос:

- `Type=0x03`
- `Data` содержит данные для записи (`DataLen>0` по смыслу команды)

Ответ:

- если команда простая и выполняется быстро: сразу `Type=0x05` и `Data` **обязательно**;
- если выполнение длительное/неопределённое: сначала `Type=0x06` и `Data` **обязательно**, затем после завершения — `Type=0x05` и `Data` **обязательно**;
- если команда неизвестна: `Type=0x00`;
- если ошибка записи: `Type=0x08`.

### 6.4. Прерывание «принятой» длительной команды

Если устройство приняло длительную команду (ответило `0x06`), а затем до завершения получает **новую** команду `Запись данных` с теми же `Node` и `Op`, то оно должно:

- прекратить выполнение ранее принятой команды;
- начать выполнять последнюю принятую команду.

Это типично для «движение в положение → стоп».

## 7. Зарезервированные команды (обязательные)

В протоколе есть зарезервированные команды, которые должны поддерживаться всеми устройствами, **за исключением УК**.

Кадры зарезервированных команд используют стандартные поля `Node`/`Op` и типы кадров из раздела 5.

### 7.1. Список зарезервированных команд (таблица 5.1)

#### Узел `Система` (`Node = 0x01`)

| Команда | `Op` | Длина данных | Доступ |
|---|---:|---:|---|
| Версия протокола | `0x01` | 2 байта | только чтение |
| Общий запрос | `0x02` | 1 байт / нет | только чтение |
| Серийный номер | `0x03` | 2 байта | только чтение |
| Версия ПО | `0x04` | 4 байта | только чтение |
| Диагностика | `0x05` | 2 байта | сообщение |
| Общий стоп | `0x07` | нет | только запись |
| Зарезервировано | `0x08..0x7F` | — | — |

#### Узел `Блокировки` (`Node = 0x02`)

| Команда | `Op` | Длина данных | Доступ |
|---|---:|---:|---|
| Разрешение | `0x01` | 2 байта | чтение/запись |
| Минимальное значение | `0x02` | 6 байт | чтение/запись |
| Максимальное значение | `0x03` | 6 байт | чтение/запись |

> Для всех команд, где в таблице задана длина данных, устройство должно обеспечивать именно этот формат данных в `Data` в кадрах чтения/записи/ответов (согласно правилам раздела 6).

### 7.2. Система → Версия протокола (`Node=0x01, Op=0x01`)

- Только чтение.
- `Data` = 2 байта, кодировка BCD по полубайтам (nibble):
  - каждый полубайт — цифра 0…9;
  - пример: версия 1.01 кодируется как `0x01 0x01` (число `0x0101`);
  - пример: версия 10.05 кодируется как `0x10 0x05` (число `0x1005`);
  - максимальная версия: `99.99` → `0x99 0x99`.

Рекомендуемый порядок байт: `[MAJOR_BCD][MINOR_BCD]` (как в примерах выше).

### 7.3. Система → Общий запрос (`Node=0x01, Op=0x02`)

- Только чтение.
- Назначение: получить от ПУ все команды протокола, которые содержат поле `Data`, без необходимости перечислять команды вручную.
- На общий запрос устройство должно выслать **все команды, содержащие поле `Data`, типом кадра `Сообщение (0x02)`**.
- По окончании устройство должно ответить кадром `Чтение успешно (0x04)` **без поля `Data`**.

#### 7.3.1. Полудуплексные шины ВУ–ПУ

Команда имеет 1 байт данных, используемый только в полудуплексных шинах для исключения ситуации «один запрос — много ответов».

Порядок работы:

1. ВУ отправляет `Чтение данных (0x01) → система → общий запрос` с `Data[0] = 1`.
2. ПУ имеет конечный список команд и счётчик списка. При получении запроса с `Data[0]=1` счётчик обнуляется. В ответ отправляется **первый кадр** из списка (тип `Сообщение (0x02)`).
3. ВУ отправляет `Чтение данных (0x01) → система → общий запрос` с `Data[0] = 0`.
4. ПУ при получении запроса с `Data[0]=0` увеличивает счётчик и отправляет **следующую команду** из списка (тип `Сообщение (0x02)`). Если счётчик достиг конца списка, вместо сообщения ПУ отвечает `Чтение успешно (0x04) → система → общий запрос` **без поля `Data`**.
5. ВУ повторяет п.3, пока не получит финальный `Чтение успешно`.

#### 7.3.2. Полнодуплексные шины

В полнодуплексных шинах байт данных игнорируется (можно использовать общий запрос без поля данных).

### 7.4. Система → Серийный номер (`Node=0x01, Op=0x03`)

- Только чтение.
- `Data` = 2 байта.
- Серийный номер — идентификатор устройства/робота.
- Кодируется аналогично версии протокола (BCD по полубайтам).

### 7.5. Система → Версия ПО (`Node=0x01, Op=0x04`)

- Только чтение.
- `Data` = 4 байта:

```
byte0: MAJOR    (MSB)
byte1: MINOR
byte2: REV_H
byte3: REV_L    (LSB)
```

`REV_H` и `REV_L` — версия ревизии в системе контроля версий.

### 7.6. Система → Диагностика (`Node=0x01, Op=0x05`)

- Представляет собой кадр типа `Сообщение (0x02)`, который шлётся устройством при определённом событии.
- `Data` = 2 байта: знаковое 16‑битное число, **не равное 0**.
  - `abs(value)` — код события;
  - знак: `+` — событие произошло, `-` — события нет.

> Порядок байтов знакового 16‑битного значения спецификацией не задан. Рекомендуется использовать network order (MSB first) и зафиксировать это в проекте.

### 7.7. Система → Общий стоп (`Node=0x01, Op=0x07`)

- Только запись.
- При получении команды устройство должно остановить все работающие приводы.
- Если устройство не имеет приводов, должен быть отправлен ответ типа `Ошибка записи (0x08)`.

### 7.8. Блокировки (Node = 0x02)

Блокировки используются для ограничения перемещения исполнительных механизмов устройства в заданных пределах.

#### 7.8.1. Блокировки → Разрешение (`Op=0x01`)

- Чтение/запись.
- `Data` = 2 байта: идентификатор блокировки, знаковое 16‑битное число, **не равное 0**.
  - `id > 0` → блокировка разрешена;
  - `id < 0` → блокировка запрещена.

#### 7.8.2. Блокировки → Минимальное значение (`Op=0x02`)

- Чтение/запись.
- `Data` = 6 байт:
  - первые 2 байта — идентификатор блокировки (как выше);
  - следующие 4 байта — минимальное значение датчика.

#### 7.8.3. Блокировки → Максимальное значение (`Op=0x03`)

- Чтение/запись.
- `Data` = 6 байт:
  - первые 2 байта — идентификатор блокировки (как выше);
  - следующие 4 байта — максимальное значение датчика.

> Спецификация 4.02 не уточняет формат 4‑байтного значения датчика (знаковость/тип/порядок байтов). Это должно быть определено проектом/устройством‑владельцем команды.

## 8. Требования к реализации парсера (stream)

Поскольку `PREAMBLE=0xFF` не является уникальным маркером начала кадра, надёжный парсер в потоковом интерфейсе (UART/RS‑485) должен:

1. Сканировать поток до первого `0xFF`.
2. После `0xFF` читать байт `Length`.
3. Если `Length` вне допустимого диапазона (8…255) — сдвигаться на следующий возможный `0xFF` и продолжать.
4. Считать ровно `Length` байт `FRAME`.
5. Проверить CRC16 согласно разделу 4.4.
6. При ошибке CRC — выполнить ресинхронизацию: искать следующий `0xFF` внутри накопленного окна/последующих байт.

Рекомендуется использовать таймаут межбайтового разрыва на физическом уровне (UART) как дополнительный механизм восстановления синхронизации (не описан спецификацией, но полезен на практике).

## 9. Требования к реализации (UDP)

При использовании UDP/IP:

- Один UDP‑датаграмм может содержать один кадр PCcom.
- Если в датаграмме содержится более одного кадра или кадр фрагментирован, это поведение должно быть определено проектом (спецификация 4.02 этого не нормирует).

## 10. Расширение протокола пользовательскими командами

Пользовательские команды определяются через `Node`/`Op` и трактовку `Data` устройством‑владельцем команды.

Для совместимости рекомендуется:

- считать `Data` **последовательностью байт** (типизация/эндианность — часть контракта конкретной команды);
- фиксировать длину `Data` для каждой команды и валидировать её на приёме;
- на неизвестные `Node`/`Op` отвечать `Type=0x00` для `Чтение данных`/`Запись данных`;
- на `Сообщение` не отвечать.

---

## 11. Профиль проекта MFDC (плата ↔ ПК): сервисы `ManualDuty` и `SelfTest`

Этот раздел — **проектное расширение** поверх PCcom 4.02, описывающее сервисные команды для отладки и производственной диагностики (см. `docs/design-notes/DN-002_MFDC_ManualDuty_Service_Mode.md`, `docs/PROJECT_CONTEXT.md` и `docs/TEST_PLAN.md`).

### 11.1. Общие правила

- Все многобайтные поля в `Data` в этом профиле кодируются в **network order (MSB first)**.
- Режим `ManualDuty` активируется только сервисными командами, и при потере сервис-связи > **20 мс** устройство обязано перейти в safe state и отключить `ManualDuty`.
- Под “связью” в `ManualDuty` понимается приход **любой валидной** команды узла `MFDC Service` (включая keepalive), по тому же физическому интерфейсу/каналу, через который режим был включён.

#### 11.1.1. Политика настройки регулятора тока (tuning)

- Параметры настройки контура регулирования тока (коэффициенты регулятора и связанные с ними калибровки/константы) являются **сервисными** и допускаются к изменению **только через сервисное ПО по UART (PCcom)**.
- По CAN удалённая запись tuning-параметров запрещена (см. `docs/protocols/PROTOCOL_TK.md`): любые команды/операции, пытающиеся изменить коэффициенты/калибровки, должны быть отклонены и не должны приводить к изменениям ни в ОЗУ, ни в NVM.
- Применение изменений: on-the-fly запрещено; изменение tuning-параметров допускается только в `Service mode` и только при запрещённой сварке (не `ARMED/WELD`, PWM подтверждён как OFF). Применение — по явной команде `Apply/Commit` (либо через перезапуск по проектной политике).
- Целостность/валидация: формат данных tuning-параметров должен включать версию структуры и CRC; значения должны проходить жёсткую валидацию (диапазоны, запрет NaN/Inf, знаки/тип). При ошибке валидации/CRC/версии запись и применение запрещаются.
- Fail-safe для NVM: если при старте обнаружены некорректные tuning-данные (CRC/версия/валидация), устройство должно использовать безопасный набор по умолчанию и запрещать переход в режимы, где требуется корректный контур, до сервисного исправления.

### 11.2. Узел `MFDC Service` (`Node = 0x30`)

#### 11.2.1. `ManualDuty.Control` (`Op = 0x01`, запись)

Назначение: включить/выключить `ManualDuty` и (опционально) задать параметры.

Запрос:
- `Type = 0x03` (Запись данных)
- `Data` = 8 байт:
  - `byte0`: `flags` (u8)
    - bit0: `enable` (1=включить `ManualDuty`, 0=выключить)
    - bit1: `apply_preload_only` (должен быть 1; в противном случае команда отвергается)
    - bits2..7: reserved (=0)
  - `byte1`: `reserved` (=0)
  - `byte2..3`: `duty_target_permille` (u16), 0…1000 (0.1%/LSB). Для `ManualDuty` диапазон применения: **100…500** (10–50%).
  - `byte4..5`: `slew_rate_permille_per_period` (u16), ограничитель изменения скважности “на период ШИМ” в единицах 0.1%/период:
    - 0 ⇒ использовать default **2‰/период**
    - допустимый диапазон: **1…10‰/период**
    - вне диапазона ⇒ команда отвергается (ошибка валидации)
  - `byte6..7`: `reserved` (=0)

Ответ:
- если успешно: `Type = 0x05` (Запись успешна), `Data` = 2 байта `result_code` (u16, MSB first), где `0x0000` = OK
- если ошибка записи/валидации: `Type = 0x08` (Ошибка записи), `Data` = 2 байта `error_code` (u16, MSB first), где значения фиксируются проектом (TBD)

Любой валидный `ManualDuty.Control` сбрасывает таймер сервис-связи для `ManualDuty`.

#### 11.2.2. `ManualDuty.KeepAlive` (`Op = 0x02`, запись)

Назначение: поддержание сервис-связи без изменения параметров.

Запрос:
- `Type = 0x03`
- `Data` = 1 байт: `0x00` (reserved)

Ответ:
- `Type = 0x05`, `Data` = 2 байта `result_code` (u16, MSB first), где `0x0000` = OK

#### 11.2.3. `ManualDuty.Status` (`Op = 0x03`, чтение)

Назначение: получить текущий статус режима и параметры.

Запрос:
- `Type = 0x01` (Чтение данных)
- `Data` отсутствует

Ответ:
- `Type = 0x04`, `Data` = 16 байт:
  - `byte0`: `manual_active` (u8, 0/1)
  - `byte1`: `service_iface` (u8): `0x01`=PCcom, `0x02`=CAN (native) (если поддерживается), иначе `0x00`
  - `byte2..3`: `service_link_age_ms` (u16) — время с момента последней валидной сервис-команды по интерфейсу активации
  - `byte4..5`: `duty_target_permille` (u16)
  - `byte6..7`: `duty_used_permille` (u16) — фактически применённая скважность
  - `byte8..9`: `slew_rate_permille_per_period` (u16)
  - `byte10`: `state` (u8): 0=IDLE, 1=ARMED, 2=WELD, 3=FAULT (коды фиксируются проектом; TBD)
  - `byte11`: `fault_class` (u8): 0=OK, 1=LIMIT, 2=SOFT-FAULT, 3=HARD-FAULT (TBD)
  - `byte12..15`: `reserved` (=0)

#### 11.2.4. `SelfTest.Run` (`Op = 0x10`, запись) / `RUN_SELFTEST`

Назначение: запуск встроенной самодиагностики для производства/сервиса. Команда **не должна** влиять на fast loop и не должна запускаться при активном ШИМ.

Условия допуска (gating):
- `state = IDLE`, PWM подтверждён как OFF.

Запрос:
- `Type = 0x03`
- `Data` = 2 байта:
  - `byte0`: `test_mask_lo` (битовая маска тестов)
  - `byte1`: `test_mask_hi`

Маска тестов (Draft 0.1):
- bit0: `ADC_NOISE_FLOOR` (I/U при PWM OFF)
- bit1: `VREFINT`
- bit2: `TEMPERATURE_PLAUSIBILITY` (обрыв/КЗ/диапазон)
- bit3: `SAFETY_PATH_BKIN_FLAG` (опционально, только если безопасно реализуемо)

Ответ:
- если успешно: `Type = 0x05`, `Data` = 2 байта `result_code` (u16), где `0x0000` = STARTED
- если ошибка: `Type = 0x08`, `Data` = 2 байта `error_code` (u16) (TBD)

#### 11.2.5. `SelfTest.Status` (`Op = 0x11`, чтение)

Назначение: получить статус/результаты self-test, запущенного `SelfTest.Run`.

Запрос:
- `Type = 0x01`
- `Data` отсутствует

Ответ:
- `Type = 0x04`, `Data` = 16 байт:
  - `byte0`: `selftest_state` (u8): 0=IDLE, 1=RUNNING, 2=DONE
  - `byte1`: `selftest_result` (u8): 0=OK, 1=FAIL, 2=INCONCLUSIVE
  - `byte2..3`: `fail_mask` (u16, MSB first) — биты тестов, которые не прошли
  - `byte4..5`: `warn_mask` (u16, MSB first) — биты тестов с предупреждением (опционально)
  - `byte6..7`: `adc_noise_i_rms_lsb` (u16) — RMS шума канала тока в LSB (Draft 0.1)
  - `byte8..9`: `adc_noise_u_rms_lsb` (u16) — RMS шума канала напряжения в LSB (Draft 0.1)
  - `byte10..11`: `vrefint_mV` (u16) — оценка VDD по VREFINT (мВ) (Draft 0.1)
  - `byte12`: `temp1_status` (u8): 0=OK, 1=OPEN, 2=SHORT, 3=OUT_OF_RANGE (Draft 0.1)
  - `byte13`: `temp2_status` (u8): аналогично (Draft 0.1)
  - `byte14..15`: `reserved` (=0)
