# PCCOM 4.02 — профиль проекта (WC_IST)

Этот документ содержит проектные узлы/команды и соглашения поверх базовой спецификации PCcom 4.02.
Базовая спецификация: `docs/protocols/PCCOM4.02.md`.

## 1. Общие сведения

### 1.1. Адресация проекта

| Адрес PCcom4 / CAN | Адресат |
|---:|---|
| `0x01` | ПК / ТК |
| `0x03` | плата источника сварочного тока (УСПФ) |

### 1.2. Длина поля `Data` и длина кадра

DataLen — длина поля `Data` (в байтах).

Длина кадра на линии (включая `PREAMBLE=0xFF`) = `9 + DataLen`.

### 1.3. Кодирование многобайтных чисел

Правило по умолчанию (проектное):
- если для поля указано `u16/u32/i32/float` и рядом **не** написано “MSB first” → использовать **little-endian**:
  - `byte0` = LSB
  - …
  - `byteN` = MSB

Исключения:
- если рядом с полем написано “MSB first” → это **network order**:
  - `byte0` = MSB
  - …
  - `byteN` = LSB
- BCD-версии и некоторые зарезервированные поля могут иметь фиксированный порядок из базовой спецификации; в этом профиле такие поля помечаются явно.

### 1.4. Правило интерфейса команд

Правило реализации (PCcom4, проектное): в одной операции меняется/читается только один параметр.

## 2. Политики проекта

### 2.1. Политика настройки параметров

- Настроечные параметры (коэффициенты контура регулирования тока, калибровки/константы, и другие параметры системы) допускаются к изменению **только через сервисное ПО по UART (PCcom)**.
- По CAN удалённая запись tuning-параметров запрещена (см. `docs/protocols/PROTOCOL_TK.md`): любые команды/операции, пытающиеся изменить коэффициенты/калибровки, должны быть отклонены и не должны приводить к изменениям ни в ОЗУ, ни во flash-памяти.
- Применение изменений: on-the-fly разрешено только для параметров, не требующих перезапуска системы; изменение настроечных параметров допускается только в `Service mode` и только при запрещённой сварке (не `ARMED/WELD`, PWM подтверждён как OFF). Сохранение изменений в flash-памяти — по явной команде `Запись настроек во flash` (либо через перезапуск).
- Целостность/валидация: значения должны проходить жёсткую валидацию (диапазоны, запрет NaN/Inf, знаки/тип). При ошибке валидации/CRC/версии запись и применение запрещаются.
- Fail-safe для flash-памяти: если при старте обнаружены некорректные настроечные параметры (CRC/версия/валидация), устройство должно использовать безопасный набор по умолчанию и запрещать переход в режимы, где требуется корректный контур, до исправления.

## 3. Узлы и операции PCcom4.02 в проекте WC_IST

### 3.1. Узел `Система` (`Node = 0x01`) — проектные операции

> Зарезервированные операции `0x01..0x7F` описаны в базовой спецификации (`docs/protocols/PCCOM4.02.md` / раздел 7). В этом документе команды `0x01`, `0x02`, `0x04` продублированы для удобства реализации на стороне ПК, а также добавлены проектные операции.

| Название операции | Операция | Длина поля данных | Доступ | Сохраняется во flash | Формат/примечание | Кодовое имя |
|---|---:|---:|---|---|---|---|
| Версия протокола (зарезервированная команда) | `0x01` | 2 | только чтение | нет | см. 3.1.1 | `System.ProtocolVersion` |
| Общий запрос (зарезервированная команда) | `0x02` | 1/0 | только чтение | нет | см. 3.1.2 | `System.GeneralRequest` |
| Версия ПО (зарезервированная команда) | `0x04` | 4 | только чтение | нет | см. 3.1.3 | `System.FwVersion` |
| Таймаут потери связи | `0x80` | 4 | чтение/запись | flash | `int32`, единицы: мс, default: 3000 | `System.LinkTimeoutMs` |
| Сброс настроек во flash к значениям по умолчанию | `0xA0` | 1 | запись | flash | записать любое значение (поле данных игнорируется) | `System.FactoryReset` |
| Запись настроек во flash | `0xA1` | 1 | запись | flash | записать любое значение (поле данных игнорируется) | `System.FlashCommit` |
| Keep alive (ПК→УСПФ) | `0xB0` | 0 | сообщение | нет | используется для контроля наличия связи | `System.KeepAlive` |

#### 3.1.1. Версия протокола (`Операция = 0x01`, только чтение)

Обмен:
- запрос: `Type = 0x01` (Чтение данных), `Data` отсутствует
- ответ: `Type = 0x04` (Чтение успешно), `Data` = 2 байта

Таблица 1 — кодирование версии протокола (2 байта, BCD по полубайтам):
- `byte0` (MSB): `MAJOR_BCD`
- `byte1` (LSB): `MINOR_BCD`

Каждый полубайт — цифра 0…9 (см. `docs/protocols/PCCOM4.02.md` / 7.2).

#### 3.1.2. Общий запрос (`Операция = 0x02`, только чтение)

Назначение: получить от ПУ все команды протокола, которые содержат поле `Data`, без необходимости перечислять команды вручную (см. `docs/protocols/PCCOM4.02.md` / 7.3).

Примечание по данным запроса:
- в полнодуплексных линиях `Data` отсутствует;
- в полудуплексных линиях используется `Data[0]` (1/0) как “сброс/следующий” (см. `docs/protocols/PCCOM4.02.md` / 7.3.1).

#### 3.1.3. Версия ПО (`Операция = 0x04`, только чтение)

Обмен:
- запрос: `Type = 0x01` (Чтение данных), `Data` отсутствует
- ответ: `Type = 0x04` (Чтение успешно), `Data` = 4 байта

Формирование версии ПО:
- `VER_MAJOR` — главная версия (меняется при изменении поведения/функционала, видимого извне).
- `VER_MINOR` — минорная версия (меняется при исправлении ошибок или внутренних изменениях без изменения внешнего поведения).
- `VER_BUILD` — номер сборки (инкрементируется автоматизированной системой сборки при изменениях в main-ветке).
- `VER_SHORTHASH` — short-hash коммита (для идентификации сборки; **в эту команду не включается**).

Упаковка в 32-битное значение:
- `MAKE_VERSION = (VER_MAJOR << 24) + (VER_MINOR << 16) + VER_BUILD`.

Передача в PCcom4:
- `Data` = 4 байта, little-endian представление `MAKE_VERSION`:
  - `byte0`: `VER_BUILD_L` (LSB)
  - `byte1`: `VER_BUILD_H` (MSB)
  - `byte2`: `VER_MINOR`
  - `byte3`: `VER_MAJOR`

Поле `VER_SHORTHASH` в команду `Версия ПО` не включается.

### 3.2. Узел `Имитация обмена с ТК по CAN` (`Node = 0x03`)

| Название операции | Операция | Длина поля данных | Доступ | Формат/примечание | Кодовое имя |
|---|---:|---:|---|---|---|
| Сообщение от ТК к УСПФ | `0x01` | 32 | сообщение | размер и формат данных будут уточнены | `TkCan.Emu.RxFrame` |
| Сообщение от УСПФ к ТК | `0x02` | 20 | сообщение | размер и формат данных будут уточнены | `TkCan.Emu.TxFrame` |

### 3.3. Узел `Настройка параметров` (`Node = 0x04`)

> Перечень операций будет расширен

| Название операции | Операция | Длина поля данных | Доступ | Сохраняется во flash | Формат | Кодовое имя |
|---|---:|---:|---|---|---|---|
| Регулятор тока: коэффициент пропорциональный (Kp) | `0x01` | 4 | чтение/запись | да | `float` | `CurrentRegulator.Kp` |
| Регулятор тока: коэффициент интегральный (Ki) | `0x02` | 4 | чтение/запись | да | `float` | `CurrentRegulator.Ki` |
| Регулятор тока: коэффициент дифференциальный (Kd) | `0x03` | 4 | чтение/запись | да | `float` | `CurrentRegulator.Kd` |

### 3.4. Узел `Управление` (`Node = 0x05`)

Для ручного режима управления скважностью (кодовые имена `ManualDuty.*`):
- при потере сервис-связи > **20 мс** устройство обязано перейти в safe state и отключить `ManualDuty`;
- под “связью” понимается приход **любой валидной** команды `ManualDuty.*` по тому же физическому интерфейсу/каналу, через который режим был включён.

| Название операции | Операция | Длина поля данных | Доступ | Сохраняется во flash | Формат/примечание | Кодовое имя |
|---|---:|---:|---|---|---|---|
| Ручной режим: включить/выключить | `0x01` | 1 | чтение/запись | нет | `u8`: `0x00`=OFF, `0x01`=ON | `ManualDuty.Enable` |
| Ручной режим: установить/прочитать целевую скважность | `0x02` | 2 | чтение/запись | нет | `u16` (0…1000, 0.1%/LSB), little-endian | `ManualDuty.DutyTargetPermille` |
| Ручной режим: установить/прочитать ограничитель изменения скважности | `0x03` | 2 | чтение/запись | нет | `u16` (0 ⇒ default 2‰/period; range 1…10‰/period), little-endian | `ManualDuty.SlewRatePermillePerPeriod` |
| Самодиагностика: запуск | `0x10` | 1 | запись/команда принята | нет | `u8`: `0x00`=OFF, `0x01`=ON (запуск полного набора тестов) | `SelfTest.Run` |
| Самодиагностика: статус/результат | `0x11` | 0 | чтение/сообщение | нет | запрос без `Data`; ответ `Data` = 16 байт (см. 3.4.2) | `SelfTest.Status` |

#### 3.4.1. Самодиагностика: запуск (`Операция = 0x10`, запись; `SelfTest.Run`)

Назначение: запуск встроенной самодиагностики для производства/сервиса. Команда **не должна** влиять на fast loop и не должна запускаться при активном ШИМ.

Условия допуска (gating):
- `state = IDLE`, PWM подтверждён как OFF.

Запрос:
- `Type = 0x03`
- `Data` = 1 байт:
  - `byte0`: `enable` (u8): `0x00`=OFF, `0x01`=ON

При `enable=0x01` запускается полный набор тестов, определённый прошивкой.
При `enable=0x00` запуск не выполняется (и/или выполняется останов/сброс самодиагностики — поведение фиксируется прошивкой).

Ответ:
- если успешно: `Type = 0x05`, `Data` = 2 байта `result_code` (u16, MSB first), где `0x0000` = OK (команда принята; при `enable=0x01` — самодиагностика запущена)
- если ошибка: `Type = 0x08`, `Data` = 2 байта `error_code` (u16, MSB first) (TBD)

Примечание: факт запуска/выполнения контролируется командой `Самодиагностика: статус/результат` (`Операция = 0x11`), поле `selftest_state`.

#### 3.4.2. Самодиагностика: статус/результат (`Операция = 0x11`, чтение; `SelfTest.Status`)

Назначение: получить статус/результаты self-test, запущенного `SelfTest.Run`.

Запрос:
- `Type = 0x01`
- `Data` отсутствует

Ответ:
- `Type = 0x04`, `Data` = 16 байт:
  - `byte0`: `selftest_state` (u8): 0=IDLE, 1=RUNNING, 2=DONE
  - `byte1`: `selftest_result` (u8):
    - `0` = OK (все тесты выполнены и пройдены)
    - `1` = FAIL (как минимум один тест не пройден; детали в `fail_mask`)
    - `2` = INCONCLUSIVE (результат неопределён: тесты не выполнены полностью или условия некорректны; детали могут быть в `fail_mask`/`warn_mask`)
  - `byte2..3`: `fail_mask` (u16, MSB first) — биты тестов, которые не прошли
  - `byte4..5`: `warn_mask` (u16, MSB first) — биты тестов с предупреждением (опционально)
  - `byte6..7`: `adc_noise_i_rms_lsb` (u16) — RMS шума канала тока в LSB (Draft 0.1)
  - `byte8..9`: `adc_noise_u_rms_lsb` (u16) — RMS шума канала напряжения в LSB (Draft 0.1)
  - `byte10..11`: `vrefint_mV` (u16) — оценка питающего напряжения `VDD` в **мВ**, рассчитанная по `VREFINT` (Draft 0.1)
  - `byte12`: `temp1_status` (u8): 0=OK, 1=OPEN, 2=SHORT, 3=OUT_OF_RANGE (Draft 0.1)
  - `byte13`: `temp2_status` (u8): аналогично (Draft 0.1)
  - `byte14..15`: `reserved` (=0)

Битовая нумерация тестов в `fail_mask`/`warn_mask` (Draft 0.1):
- bit0: `ADC_NOISE_FLOOR` (I/U при PWM OFF)
- bit1: `VREFINT`
- bit2: `TEMPERATURE_PLAUSIBILITY` (обрыв/КЗ/диапазон)
- bit3: `SAFETY_PATH_BKIN_FLAG` (опционально, только если безопасно реализуемо)

Про поле `vrefint_mV`:
- это **оценка VDD**, полезная для диагностики питания/просадок во время self-test;
- типичные значения зависят от аппаратной реализации (например, около 3300 мВ при питании 3.3 В);
- если тест `VREFINT` не выполнялся/невалиден, значение может быть 0 или оставаться неизменным — это поведение фиксируется прошивкой.

### 3.5. Узел `Цифровой осциллограф` (`Node = 0x06`)

| Название операции | Операция | Длина поля данных | Доступ | Формат/примечание | Кодовое имя |
|---|---:|---:|---|---|---|
| Осциллограф: управление передачей данных (в выбранном формате/наборе) | `0x01..0x0F` | 1 | чтение/запись | `u8`: `0x00`=OFF, `0x01`=ON | `Scope.StreamControl` |
| Осциллограф: набор / наборы данных | `0x11..0x1F` | 2..246 | сообщение | см. 3.5.1 | `Scope.Data` |

#### 3.5.1. Осциллограф: набор / наборы данных (`Операция = 0x11..0x1F`, сообщение; `Scope.Data`)

Назначение: передача данных цифрового осциллографа (потоковая выдача выбранных наборов данных).

Формат сообщения:
- `Type = 0x02` (Сообщение)
- Длина поля данных: `2..246` байт

`Data`:
- `byte0`: номер набора данных
- `byte1..N`: данные одного или нескольких наборов данных

> размер и формат данных внутри набора будут уточнены.
