# Как снимать и хранить логи CAN/CAN FD (для сниффинга и V&V)

> **УСТАРЕЛО (legacy CAN).** Документ перенесён в `docs/protocols/obsolete/` и больше не является источником правды. Актуальный протокол обмена с ТК: `docs/protocols/PROTOCOL_TK_ETHERCAT.md`.

Цель: иметь воспроизводимые артефакты обмена (логи), которые можно:
- быстро просмотреть “глазами”,
- прогнать через парсеры/скрипты,
- открыть в Wireshark/Vector инструментах,
- приложить в отчёт верификации (proof).

Связанные документы:
- `docs/protocols/obsolete/PROTOCOL_TK.md` *(устар.)* — описание протокола (каноника).
- `docs/protocols/obsolete/tk_protocol.dbc` *(устар.)* — машинно‑читаемое описание (для декодирования/сниффинга; пока скелет).

---

## 1) Форматы логов (что выбирать)

Рекомендуем держать **два** формата:

1) **Текстовый лог (candump-style)** — для grep/анализа и автоматизации
   - плюсы: прост, диффится, быстро парсится, удобно прикладывать в PR/issue
   - минусы: не так удобно в Wireshark без конвертации

2) **PCAP/PCAPNG** — для Wireshark/глубокого анализа
   - плюсы: фильтры, временные диаграммы, привычные инструменты
   - минусы: не человекочитаем в git diff

Если есть Vector‑инструменты/процесс — дополнительно хранить **ASC**.

---

## 2) Минимальный “чек‑лист” перед снятием логов

- Зафиксировать версию прошивки и ревизию железа (идентификатор сборки/коммит, вариант платы).
- Зафиксировать конфигурацию интерфейса: CAN FD, nominal/data bitrate, sample point (если важно).
- Зафиксировать сценарий: входные воздействия (команды ТК), ожидаемая реакция (статусы/таймауты/fault).
- Синхронизировать время, если используются несколько логгеров (ПК + логика/осциллограф).

---

## 3) Пример “candump‑style” логов (читаемо и парсится)

Пример строки (classic CAN):
```
can0  020   [8]  01 00 02 01 00 00 00 00
```

Для CAN FD инструменты могут писать иначе (например, с пометками FD/BRS).
Главное правило проекта: **в логах всегда хранить CAN-ID, DLC и все байты payload**.

---

## 4) Декодирование по DBC (как удобнее для инженеров)

- Для работы “в поле” удобно иметь `tk_protocol.dbc`:
  - сначала даже скелет с `b00..b63` полезен: в GUI видно разложение по байтам;
  - когда байтовая раскладка полей протокола будет зафиксирована, заменить байтовые сигналы на реальные.

Практика: в отчётах прикладывать как минимум:
- скрин/экспорт декодированных значений (`I_ref_cmd`, `state`, `fault_word`, …),
- сырой лог (candump-style или pcapng) как “source data”.

---

## 5) Рекомендации по организационным договорённостям

Чтобы сниффинг был “без боли”, стоит договориться и зафиксировать в протоколе:
- Endianness всех multi-byte полей (LE/BE) и знак (signed/unsigned).
- DLC для каждого сообщения (в т.ч. для CAN FD).
- Reserved‑поля MUST быть 0 (и валидатор должен это проверять) — помогает находить рассинхрон версий.
- Стабильный `seq` и явная политика пропусков/повторов.

---

## 6) Где хранить логи в репозитории (рекомендация)

Не коммитить большие бинарные дампы в git без необходимости.
Вместо этого:
- хранить маленькие примеры в `tests/data/can/` (если есть инфраструктура тестов),
- а “тяжёлые” логи складывать в артефакты CI/внешнее хранилище, но ссылаться на них из issue/PR.

