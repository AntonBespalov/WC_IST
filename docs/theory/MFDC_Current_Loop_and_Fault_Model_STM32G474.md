# Дополнение к архитектуре ПО MFDC-источника  
## Детализация контура тока и fault-model (STM32G474 + AD7380 + Rogowski + EtherCAT PDO 4 кГц / 250 мкс)

Связанный базовый документ: `MFDC_Software_Architecture_STM32G474.md`

---

## 1) Контур тока: цель, сигналы, дискретизация

### 1.1. Цель
Внутренний контур тока обеспечивает следование измеренного сварочного тока `I_meas`
за заданием `I_ref_fast` с минимальным джиттером, **при наличии ограничений**:
- ограничение по напряжению/скважности (headroom),
- ограничение по `di/dt`,
- ограничения трансформатора (volt-seconds / насыщение),
- аппаратные аварии (driver fault, desat и т.п.).

### 1.2. Сигналы (в терминах ПО)
- `I_samples[]` — выборки тока AD7380 в пределах одного PWM‑периода (после пересчёта/калибровки)
- `U_samples[]` — выборки напряжения в пределах одного PWM‑периода
- `I_per` — средний ток за период PWM: `mean(I_samples[])`
- `U_per` — среднее напряжение за период PWM: `mean(U_samples[])`
- `P_per` — средняя мощность за период PWM: `mean(I_samples[n] * U_samples[n])`
- `I_meas` — измеренный ток на вход регулятора (по умолчанию `I_meas = I_per`, опц. сглаженный между периодами)
- `I_ref_slow` — уставка от технологического слоя (1 кГц, EtherCAT/Process FSM)
- `I_ref_fast` — уставка, поданная в быстрый контур (после slew-rate, лимитов)
- `u_cmd` — управляющее воздействие (например, скважность `duty` или эквивалентное напряжение)
- `u_sat` — управляющее воздействие после ограничений (то, что реально ушло в PWM)

### 1.3. Частота дискретизации
- `f_pwm` (MFDC-инвертор) = **1–4 кГц**
- `f_ctrl` = `f_pwm` (1 шаг управления на период PWM)
- `f_adc` = `N * f_pwm`, где `N` — число выборок АЦП на период (N TBD)
- Важно: контрольный цикл синхронизирован с PWM (одна итерация = один период PWM).

---

## 2) Подготовка измерения тока (Rogowski + AD7380): что важно для регулятора

### 2.1. Особенность катушки Роговского
Катушка Роговского даёт сигнал, пропорциональный **производной тока**.
В реальной системе обычно присутствует:
- внешний интегратор (аналоговый) **или**
- цифровой интегратор (реже из-за требований к полосе/шуму).

Для регулятора критично:
- корректный ноль (offset),
- масштаб (gain),
- задержка канала (group delay),
- защита от дрейфа/насыщения интегратора.

### 2.2. Минимальная обработка в fast ISR
Рекомендуемая схема (лёгкая и устойчивая):
1. Перевод кодов АЦП в физические величины для всех выборок периода:
   - `I_samples[n] = (adc_i[n] - offset_i) * gain_i`
2. Де-спайк по выборкам:
   - если `|I_samples[n] - I_samples[n-1]| > I_spike_thr` → ограничить скачок или пометить sample invalid
3. Агрегация по периоду:
   - `I_per = mean(I_samples[])`
4. Опционально: 1-полюсный IIR **между периодами** (сглаживание периода к периоду):
   - `I_meas = I_meas + a * (I_per - I_meas)`
   - коэффициент `a` выбирается из компромисса шум/фаза (типично 0.05–0.2)

Примечание:
- Для PI важно не «идеально гладко», а **стабильно и без фазового убийства**.

---

## 3) PI-регулятор: дискретная математика

Ниже приведён вариант, удобный для MCU, с явным антиwindup.

### 3.1. Ошибка
`e[k] = I_ref_fast[k] - I_meas[k]`

### 3.2. Базовая форма PI (позиционная)
`u_unsat[k] = Kp * e[k] + x_i[k]`

Где `x_i[k]` — интегральное состояние.

### 3.3. Интегратор (две рабочих реализации)

#### Вариант A: обычная дискретизация (Forward Euler)
`x_i[k+1] = x_i[k] + Ki * Ts * e[k]`

Где:
- `Ts = 1 / f_ctrl`

Плюсы: просто.  
Минусы: без антиwindup быстро «надувается».

#### Вариант B: Tustin (трапеция) — мягче и часто устойчивее
`x_i[k+1] = x_i[k] + Ki * Ts * 0.5 * (e[k] + e[k-1])`

---

## 4) Saturations (ограничения) как часть регулятора

В источнике MFDC ограничения — **не исключение, а норма**.  
Поэтому правильная структура:

1) вычислить `u_unsat`  
2) применить ограничения → получить `u_sat`  
3) выполнить антиwindup на основе разницы `u_sat - u_unsat`

### 4.1. Типовые ограничения (в порядке применения)

#### 4.1.1. Duty/напряжение
`u_min ≤ u ≤ u_max`

- `u_max` определяется DC-link, топологией, запасом по напряжению
- `u_min` часто 0 (или небольшой минимум для драйверов/мёртвых зон)

#### 4.1.2. Slew-rate по выходу (ограничение du/dt)
`u_sat[k] = clamp(u_sat[k-1] + du_max, u_sat[k-1] - du_max, u_prelim[k])`

Нужно для:
- мягкого управления трансформатором,
- подавления возбуждения из-за резких ограничений.

#### 4.1.3. Slew-rate по уставке (ограничение dI_ref/dt)
Это лучше делать **до PI**, в формировании `I_ref_fast`:
`I_ref_fast[k] = clamp(I_ref_fast[k-1] ± dI_ref_max, I_ref_slow[k])`

#### 4.1.4. Volt-seconds / защита от насыщения
Вводится «интегратор напряжения на первичке» или эквивалент по duty:

`Vsec_est ~ duty * Vdc / N`
`Φ_est[k+1] = Φ_est[k] + Vsec_est[k] * Ts`

Если `|Φ_est| > Φ_limit` → принудительное ограничение `u_max` или переход в режим размагничивания.

---

## 5) Антиwindup: два надёжных подхода

### 5.1. Back-calculation (рекомендуется)
После ограничения:

`aw[k] = Kaw * (u_sat[k] - u_unsat[k])`

Интегратор:

`x_i[k+1] = x_i[k] + Ki*Ts*e[k] + aw[k]`

Смысл:
- когда управление упёрлось в потолок, интегратор «возвращают назад»,
- снижает время выхода из насыщения.

Практика:
- `Kaw` подбирается так, чтобы AW был достаточно быстрым, но не возбуждал (типично 1…10 * Ki).

### 5.2. Conditional integration (простая и «железобетонная»)
Интегрировать только когда это помогает выйти из насыщения:

Если:
- `u_unsat > u_max` и `e > 0` → **не интегрировать**
- `u_unsat < u_min` и `e < 0` → **не интегрировать**
Иначе интегрировать по стандартной формуле.

Плюсы:
- очень предсказуемо,
- проще валидировать.

Минусы:
- иногда чуть хуже динамика, чем у back-calculation.

---

## 6) Дополнительные «обязательные» элементы регулятора

### 6.1. Ограничение интегратора (integrator clamping)
Даже с AW полезно ограничить `x_i`:
`x_i_min ≤ x_i ≤ x_i_max`

Границы выбирают так, чтобы суммарное `u` могло лежать в `[u_min, u_max]`.

### 6.2. Dead-zone / минимально эффективная скважность
В MFDC часто есть зона, где изменение duty почти не даёт тока (мёртвая зона).
Можно:
- добавить `u_bias` (компенсация),
- или использовать таблицу/профиль трансформатора.

### 6.3. Feed-forward (по желанию, сильно помогает)
Если есть оценка связи `I ≈ G * u` в рабочей точке:

`u_ff = I_ref_fast * inv_G`

Тогда PI работает как «доводчик», что:
- уменьшает интегральную нагрузку,
- ускоряет реакцию при изменении уставки.

`u_unsat = u_ff + Kp*e + x_i`

---

## 7) Режим «не могу набрать ток» (headroom limit)

Это штатная ситуация, когда:
- `u_sat` постоянно в `u_max`,
- а `I_meas` существенно ниже `I_ref_fast`.

Детектор (в fast или медленном слое):
- `u_sat == u_max` непрерывно более `T_headroom` (например, 5–20 мс),
- и `I_meas < I_ref_fast - I_headroom_err`.

Реакция зависит от политики:
- **Вариант 1 (мягкий):** ограничить `I_ref_fast` до достижимого и поднять флаг `LIMITED_BY_VOLTAGE`
- **Вариант 2 (жёсткий):** fault `CANNOT_REACH_SETPOINT` (обычно только если это не ожидается технологией)

---

# 8) Fault-model: классы ошибок, защёлки, реакции

## 8.1. Цели fault-модели
- Безопасное состояние при аварии
- Предсказуемые реакции (для верификации)
- Отделение «мягких» ограничений от «жёстких» аварий
- Диагностика и телеметрия для ТК

---

## 8.2. Классы ошибок

### A) HARD-FAULT (немедленная остановка, защёлка)
Характер: опасно для силовой части / человека / оборудования.

Примеры:
- `DRV_FAULT` (Skyper fault, desat, UVLO драйвера)
- `OVERCURRENT_FAST` (мгновенный сверхток по I_meas)
- `ADC_FAULT` (SPI/DMA timeout, out-of-range, stuck code)
- `HW_TRIP` (аппаратный trip PWM/компаратор)
- `THERMOSTAT_TRIP` (термостат трансформатора/модуля)
- `DC_LINK_OV/UV` (если измеряется и критично)

Реакция:
- мгновенно `PWM_DISABLE`
- `GATE_ENABLE = 0` (если есть отдельный сигнал)
- защёлка до явного сброса (reset command / power-cycle / service)

---

### B) PROTECTIVE LIMIT (не авария, но ограничение режима)
Характер: управление упёрлось в пределы; сварка может продолжаться с деградацией.

Примеры:
- `LIMIT_BY_VOLTAGE` (headroom)
- `LIMIT_BY_DIDT`
- `LIMIT_BY_VS` (volt-seconds)
- `SATURATION_SUSPECTED` (подозрение на насыщение без явного HW trip)

Реакция:
- продолжать регулирование в пределах лимитов
- выставить статус-флаги и/или деградировать профиль (например, снижать I_ref)
- при длительности > порога → эскалация (например, в soft-fault или abort weld)

---

### C) SOFT-FAULT / ABORT WELD (прервать импульс, но без глобальной защёлки)
Характер: качество/процесс нештатны, но не обязательно опасно железу.

Примеры:
- `NO_CURRENT_DETECTED` при duty>min (обрыв цепи/не зажатые детали)
- `EXCESSIVE_SPATTER_INDICATOR` (по R_dyn / V / I признакам)
- `UNSTABLE_REGULATION` (перерегулирование выше порога)
- `SENSOR_DRIFT` (offset ушёл за допуск)

Реакция:
- прекратить текущую сварку (WELD_ABORT)
- перейти в HOLD/IDLE
- разрешить повтор только после подтверждения ТК или по таймеру

---

### D) INFO / MAINTENANCE (диагностика, без влияния на процесс)
Примеры:
- `CALIBRATION_DUE`
- `TEMP_HIGH_WARN`
- `CAN_TIMEOUT_WARN` (если есть резервный режим)

Реакция:
- только телеметрия

---

## 8.3. Правила защёлок (latch policy)

### 8.3.1. Защёлка HARD-FAULT
- latch всегда
- сброс только:
  - команда `FAULT_RESET` от ТК + условия безопасности (PWM выключен, time since fault > Tmin)
  - или power-cycle / reset

### 8.3.2. Защёлка SOFT-FAULT
- latch до конца текущего цикла
- сброс при входе в IDLE и подтверждении от ТК (или автоматически по политике)

### 8.3.3. Non-latch для LIMIT
- не latch
- но с накоплением времени в лимите:
  - `t_limit_accum += Ts`
  - при превышении порога → эскалация в SOFT-FAULT или ABORT

---

## 8.4. Реакции по слоям (кто что делает)

### Fast ISR слой
- фиксирует критические признаки
- выполняет немедленный `PWM_DISABLE` на HARD-FAULT
- выставляет atomic `fault_flags_fast`

### RTOS слой
- агрегирует fault-слова (fast + slow)
- управляет состояниями FSM (ABORT/FAULT/IDLE)
- отправляет в ТК (EtherCAT TxPDO; при наличии legacy CAN *(устар.)* — соответствующий профиль):
  - `status_word`
  - `fault_word`
  - `limit_word`
- ведёт счётчики, лог

---

## 8.5. Формат fault-слов (рекомендация)
- `fault_word` (32 бита): только HARD/ SOFT faults
- `limit_word` (32 бита): только ограничения (LIMIT)
- `status_word` (32 бита): состояние FSM + режимы + ready/busy

Плюс счётчики:
- `fault_counter[id]`
- `last_fault_timestamp`
- `time_in_limit[id]`

---

## 8.6. Минимальный перечень fault/limit для твоего стенда

### HARD
- DRV1_FAULT, DRV2_FAULT
- OC_FAST
- ADC_SPI_TIMEOUT
- ADC_RANGE
- THERMOSTAT
- HW_TRIP

### LIMIT
- LIMIT_DUTY_MAX (headroom)
- LIMIT_DIDT
- LIMIT_VS
- SATURATION_SUSPECTED

### SOFT / ABORT
- NO_CURRENT (при duty>min)
- CANNOT_REACH_SETPOINT (по политике)
- REGULATION_UNSTABLE (если нужен)

---

## 9) Рекомендованные тесты (кратко, для верификации)
(Не план действий, а список того, что архитектурно требуется проверить.)

- Step-response тока при разных L/R (эмуляция нагрузки)
- Длительная работа в `u_max` без windup (проверка AW)
- Переключение профилей трансформатора (устойчивость параметров)
- Инжекция faults: driver fault, ADC timeout, OC
- Проверка latch/reset политики и отчётов в ТК (EtherCAT/legacy CAN *(устар.)*)

---

## 10) Короткий практический шаблон параметров PI (что хранить в профиле)

- `Kp`, `Ki`, `Kaw` (или режим conditional)
- `u_min`, `u_max`
- `du_max` (slew по u)
- `dI_ref_max` (slew по уставке)
- `I_spike_thr`, `a_iir`
- `Φ_limit` (volt-seconds) и стратегия размагничивания/лимита

---

Конец документа.

