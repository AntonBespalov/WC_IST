# Red-team review: timing_epoch guard в PSRAM QSPI

## Объект ревью

Ревью выполнено по изменениям коммита `14b85e0`:
- `Fw/bsp/qspi_port.h`
- `Fw/drivers/psram_aps6404l.c`
- `Fw/drivers/psram_aps6404l.h`
- `tests/unit/psram_aps6404l_tests.c`

Контекст безопасности/RT: `docs/CONTEXT_SNAPSHOT.md` (safe state, наблюдаемость, измерения таймингов).

## Найденные риски (red-team)

> Формат: **Симптом → Причина → Воспроизведение → Доказательство → Минимальная правка**.

1. **Ложный READY при late-изменении таймингов вокруг `psram_recover()`**
   - Симптом: после recover драйвер в `READY`, но первая же транзакция может оказаться на устаревших фактических настройках QSPI.
   - Причина: snapshot обновляется до/без атомарной фиксации “настройки применены и стабильны”.
   - Воспроизведение: fault-injection — изменить prescaler/mode в BSP в окне между recover и первым read/write.
   - Доказательство: GPIO-маркеры на вход/выход recover + лог `timing_epoch_snapshot/port.timing_epoch`.
   - Минимальная правка: ввести BSP-барьер `qspi_port_apply_timing_and_bump_epoch()` и обновлять snapshot только после успешного apply+idle.

2. **Race при чтении `port.timing_epoch` без синхронизации между контекстами**
   - Симптом: спорадические `NOT_READY/DEGRADED` без видимой причины.
   - Причина: поле читается/пишется из разных контекстов (task/ISR) без явного memory-order/critical section.
   - Воспроизведение: stress test с частыми сменами частоты QSPI и параллельным read/write.
   - Доказательство: trace событий epoch-change vs read/write reject.
   - Минимальная правка: сделать доступ к epoch через atomic API/critical section и запретить ISR-перезапись без протокола.

3. **ABA-проблема epoch (переполнение 32-бит)**
   - Симптом: через длительное время может совпасть “старое” и “новое” значение, проверка пропустит рассинхрон.
   - Причина: простое сравнение равенства без защиты от wrap-around/доп. метки конфигурации.
   - Воспроизведение: unit/fuzz, эмулировать близость к `UINT32_MAX`, затем два цикла wrap.
   - Доказательство: лог последовательности epoch и snapshot.
   - Минимальная правка: использовать 64-бит epoch либо структуру signature (epoch + config_crc).

4. **Неопределённый контракт “кто и когда обязан инкрементировать epoch”**
   - Симптом: guard не срабатывает при реальном изменении тайминга, если BSP забывает bump.
   - Причина: требование описано комментарием, но не enforce-ится API-интерфейсом.
   - Воспроизведение: изменить QSPI timing в BSP без инкремента — read/write пройдут.
   - Доказательство: bench-лог ошибок шины при `epoch` неизменном.
   - Минимальная правка: убрать прямой доступ к полю, предоставить только setter, который одновременно применяет timing и bump.

5. **Переход в `DEGRADED` на одиночном mismatch может вызвать лишнюю остановку буферизации**
   - Симптом: кратковременный служебный retune QSPI приводит к деградации и отказу сервиса выше.
   - Причина: mismatch трактуется как hard-not-ready без отдельного кода “timing changed, recover required”.
   - Воспроизведение: инъекция однократной смены epoch при нормальном железе.
   - Доказательство: лог state transitions `READY->DEGRADED` при нулевых bus/timeout ошибках.
   - Минимальная правка: отдельный код ошибки `PSRAM_ERR_TIMING_CHANGED` + policy в верхнем уровне.

6. **Отсутствие теста на конкурентный доступ lock + timing mismatch**
   - Симптом: возможно нарушение ожидаемой семантики (LOCKED vs NOT_READY) при гонке.
   - Причина: unit-тесты покрывают lock и mismatch отдельно.
   - Воспроизведение: два task-id, один держит lock, второй вызывает read при epoch mismatch.
   - Доказательство: unit-test matrix по порядку проверок/возвратов.
   - Минимальная правка: добавить тесты приоритета ошибок и документировать порядок проверок.

7. **Неполная проверка recover-сценария после mismatch**
   - Симптом: recover может вернуть READY, но I/O path после recover не верифицирован end-to-end.
   - Причина: тест проверяет только state, но не успешный read/write после восстановления.
   - Воспроизведение: после recover выполнить write+read compare.
   - Доказательство: unit-test с payload round-trip и счётчиками транзакций.
   - Минимальная правка: расширить `test_recover_after_timing_epoch_change` проверкой функционального I/O.

8. **Риск потери диагностичности (причина деградации не различима)**
   - Симптом: в телеметрии `NOT_READY`, но непонятно — init, transport fault или timing mismatch.
   - Причина: используется общий код ошибки/счётчики без cause-tag.
   - Воспроизведение: собрать логи при трёх разных причинах деградации.
   - Доказательство: одинаковые коды в журнале при разных первопричинах.
   - Минимальная правка: добавить отдельный reason code в `psram_status_t` (например `last_not_ready_reason`).

9. **Потенциальный false-negative при кешировании структуры API копированием**
   - Симптом: если BSP меняет timing вне `ctx->port` копии, guard может не увидеть изменение.
   - Причина: `qspi_port_api_t` хранится по значению в контексте, не по ссылке на живой объект версии.
   - Воспроизведение: изменить глобальный BSP epoch, не обновляя копию в driver ctx.
   - Доказательство: mismatch в BSP есть, а driver продолжает операции.
   - Минимальная правка: хранить в ctx указатель на immutable API + отдельный shared epoch source.

10. **Нет доказательства временной стоимости новой проверки в критическом пути**
   - Симптом: возможный рост jitter read/write вызовов в высокочастотном режиме логгера.
   - Причина: добавлен новый conditional check/state update, но нет измерений.
   - Воспроизведение: on-target benchmark до/после патча на целевой частоте обмена.
   - Доказательство: GPIO toggle вокруг API + осциллограф (распределение latency/jitter).
   - Минимальная правка: добавить micro-benchmark и acceptance threshold в тест-план.

11. **Семантика recover не учитывает “в полёте” транзакции DMA в нижнем слое**
   - Симптом: recover/epoch update может наложиться на незавершённый transfer.
   - Причина: нет явного handshake “порт idle” перед snapshot/state READY.
   - Воспроизведение: fault-injection с задержанным завершением low-level transfer.
   - Доказательство: лог DMA busy flag и момент смены state.
   - Минимальная правка: в recover добавить обязательную проверку `port.is_idle()`/barrier.

12. **Не проверен путь self_test при mismatch epoch**
   - Симптом: self_test может давать “OK” в состоянии, где read/write уже блокируются.
   - Причина: нет связанного теста self_test после искусственного epoch mismatch.
   - Воспроизведение: поменять epoch и вызвать `psram_self_test`.
   - Доказательство: сравнить код возврата self_test и state/операции I/O.
   - Минимальная правка: добавить unit-test и/или изменить self_test так, чтобы он валидировал epoch-consistency.

## Что обязательно измерить на железе

1. Латентность и джиттер `psram_read()/psram_write()` до/после патча (GPIO-тоггл на вход/выход API).
2. Время реакции на mismatch epoch: момент смены epoch → первый `NOT_READY`.
3. Детерминизм recover: `recover start` → `READY` (с минимум/максимум/σ).
4. Поведение при одновременном изменении QSPI тайминга и активном DMA-трафике.
5. Корреляция ошибок шины QSPI и смены `timing_epoch` в логах.
6. Проверка отсутствия ложных деградаций при длительном soak-test.
7. Нагрузка fast/slow loop: влияние guard на CPU budget и worst-case latency.
8. Полный путь safety-диагностики: как код причины деградации доходит до телеметрии верхнего уровня.
9. Временная связь с критичными сигналами силовой части (для исключения побочного влияния): `BKIN_RAW` и `PWM_OUT` параллельно с нагрузкой QSPI.
10. Проверка, что при fault/recover не происходит блокирующих участков, нарушающих 250 мкс сервисный цикл обмена.

