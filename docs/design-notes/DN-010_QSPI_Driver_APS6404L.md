Статус: draft  
Дата: 2026-02-12  
Владелец: Codex/LLM draft  
Связано:  
- `docs/CONTEXT_SNAPSHOT.md`  
- `docs/PROJECT_CONTEXT.md`  
- `docs/GLOSSARY.md`  
- `docs/ARCHITECTURE.md`  
- `docs/TEST_PLAN.md`  
- `docs/design-notes/DN-005_QSPI_PSRAM_Oscilloscope_Buffer.md`  

---

## 1) Spec (требования, критерии приёмки, инварианты)

### 1.1 Входные рамки (по Gate М1–М5)
- М1: цель — разработать драйвер QSPI для PSRAM `APS6404L-3SQR-SN`; не менять контуры сварки/control/fault/comms.
- М2: разрешённая зона изменений (план) — только memory/QSPI слой (`Fw/bsp/*qspi*`, `Fw/drivers/*psram*`, `Fw/app/memory/*`) и связанные unit-тесты.
- М3: контекст исполнения — task-only API; из ISR прямые вызовы драйвера запрещены.
- М4: временной домен не определён пользователем → по безопасному допущению считать путь RT-чувствительным; проектировать так, чтобы исключить влияние на fast loop.
- М5: критерий done — Build + on-target проверки + осциллографические измерения интерфейса и задержек.

### 1.2 Цель изменения
Разработать минимально-достаточный, детерминированно-интегрируемый драйвер QSPI PSRAM (APS6404L) для сервисного тракта буферизации, без изменения поведения fast PWM-контура и safe-state политик.

### 1.3 Non-goals (что НЕ меняем)
- Не менять shutdown-path (BKIN/BKIN2, DRV_EN/INH), fault-логику, state machine сварки.
- Не использовать PSRAM как XIP/исполняемую память.
- Не добавлять динамическую память в fast/ISR путях.
- Не менять протоколы обмена с ТК.

### 1.4 Функциональные требования (SHALL)
1. Драйвер SHALL поддерживать этапы: `Init`, `Read`, `Write`, `SelfTest`, `GetStatus`, `Recover`.
2. Драйвер SHALL проверять доступность микросхемы при старте (ID/readback-паттерн и базовая пробная транзакция).
3. Драйвер SHALL обеспечивать доступ по адресному пространству PSRAM с контролем границ.
4. Драйвер SHALL возвращать формализованные коды ошибок: `TIMEOUT`, `BUS`, `PARAM`, `NOT_INIT`, `NOT_READY`, `DATA_MISMATCH`.
5. Драйвер SHALL быть re-entrant-safe на уровне task-контекста через явную сериализацию доступа (mutex/owner task policy — фиксируется в реализации).
6. Драйвер SHALL иметь режим деградации: при повторяющихся ошибках переводить подсистему PSRAM в `DEGRADED/OFF`, не влияя на fast loop.
7. Драйвер SHALL поддерживать chunked transfer (ограничение размера транзакции), чтобы исключить длинные монопольные участки CPU.
8. Драйвер SHALL иметь возможность включения/выключения memory-mapped режима compile-time/runtime флагом (по итогам верификации).

### 1.5 Временные/интеграционные требования
1. Любые QSPI операции выполняются только в slow task.
2. В fast loop/ISR допустима только O(1) работа с SRAM-буфером; обращение к QSPI из fast/ISR SHALL NOT.
3. При перегрузке/ошибке QSPI должна происходить контролируемая деградация функции осциллографа/логгера без влияния на управление сваркой.

### 1.6 Критерии приёмки (Done)
1. Сборка проекта проходит с включённым и выключенным флагом PSRAM-драйвера.
2. На target подтверждены: init OK, чтение/запись блоков, проверка паттернов (`0x00/0xFF/0xAA55/PRBS`) без ошибок на целевом объёме.
3. Измерены сигналы QSPI (CS/SCK/IO0..IO3), частота/режим/dummy cycles согласованы с ожидаемым режимом работы.
4. Зафиксировано, что включение драйвера не ухудшает критичные метрики fast loop (по методике из раздела Tests/Proof).
5. При fault-injection подтверждена деградация PSRAM-функции без изменения safety-инвариантов системы.

### 1.7 Инварианты безопасности/архитектуры
- Инвариант S1: отказ QSPI/PSRAM не может разрешать сварку и не должен изменять поведение shutdown-path.
- Инвариант S2: fast loop не зависит от доступности PSRAM.
- Инвариант S3: восстановление после ошибки PSRAM только через явный recovery путь, без скрытого авто-restore в критичном контексте.

---

## 2) DN draft (что/как/почему + test plan/rollback)

### 2.1 Что делаем
- Добавляем отдельный слой драйвера APS6404L над HAL QSPI.
- Интерфейс драйвера ограничиваем простыми примитивами block read/write и health-monitoring.
- Интеграция в приложение — только через memory service в slow task.

### 2.2 Как делаем (архитектурно)
- HAL/BSP слой: инициализация периферии QSPI, low-level транзакции, timeout handling.
- Driver слой: state machine драйвера (`UNINIT`, `READY`, `BUSY`, `DEGRADED`, `FAULT`), валидация параметров, ретраи с лимитом.
- App/memory слой: неблокирующий policy-вызов в slow task, backpressure и отключение функции при ошибках.

### 2.3 Почему так
- Разделение уровней снижает риск влияния на RT-домен.
- Формализованная деградация поддерживает наблюдаемость и предсказуемость отказов.
- Chunked I/O ограничивает worst-case блокировки в slow domain и упрощает доказательство таймингов.

### 2.4 Rollback
- Feature flag `PSRAM_ENABLE=0`: отключение использования PSRAM и возврат к SRAM-only буферизации.
- При rollback не меняем контуры безопасности/управления, только service-path.

---

## 3) Tests/Proof (unit/on-target/HIL/fault-injection + осциллограф)

### 3.1 Host unit tests (driver logic, без STM32-регистров)
1. Границы адресации и длины: reject invalid params.
2. Переходы состояний драйвера (`UNINIT->READY->BUSY->READY`, fault path).
3. Политика ретраев и переход в `DEGRADED` после N ошибок.
4. Chunk splitter: корректное разбиение длинных запросов.
5. Сериализация доступа из двух task-клиентов (mock scheduler/lock).

### 3.2 On-target tests
1. Smoke init: успешный старт драйвера, базовый self-test.
2. R/W тест по диапазонам адресов: минимум начало/середина/конец доступного окна.
3. Паттерн-тесты: `0x00`, `0xFF`, `0xAA55`, PRBS32, с verify-readback.
4. Throughput/latency: запись и чтение блоками 256B/1KB/4KB/16KB.
5. Long run (>=1h): циклическая запись/чтение + счёт ошибок/ретраев.

### 3.3 Осциллографические измерения (обязательно)
1. Проверить CS/SCK/IO[0..3] на корректность режима и частоты.
2. Зафиксировать длительность транзакций для разных chunk size.
3. Сопоставить активность QSPI с метками DBG0/DBG1 и убедиться, что fast loop метрики не деградируют.

### 3.4 Fault-injection (минимум 5 сценариев)
1. Таймаут транзакции (искусственно завышенный wait) → код `TIMEOUT`, счётчик ошибок++, возможный переход в `DEGRADED`.
2. Ошибка шины/прерывание транзакции → корректное завершение и отсутствие deadlock.
3. Data mismatch при verify-readback → `DATA_MISMATCH`, событие диагностики.
4. Инициализация недоступна (эмуляция отсутствия PSRAM) → сервис отключён, остальная система штатна.
5. Перегрузка запросами от клиента (burst) → backpressure/drop policy без влияния на fast loop.

### 3.5 HIL / bench
- Совместный прогон с активной сервисной телеметрией и имитацией длительной сварочной сессии.
- Критерий: нет изменения поведения safety-state, нет роста fault по силовой части из-за активности QSPI.

---

## 4) Code plan (файлы + план коммитов, без реализации)

### 4.1 Разрешённые файлы (из запроса)
- `Fw/bsp/*qspi*`
- `Fw/drivers/*psram*`
- `Fw/app/memory/*`
- `tests/*` (unit для driver logic)

### 4.2 План коммитов
1. **Commit 1 (scaffold):** каркас API драйвера и типы статуса/ошибок; feature-flag в конфиге.
2. **Commit 2 (HAL/BSP integration):** low-level QSPI init + indirect read/write + timeout handling.
3. **Commit 3 (driver logic):** state machine, retry/degrade policy, self-test/readback.
4. **Commit 4 (app integration):** подключение в memory service slow task, без fast/ISR вызовов.
5. **Commit 5 (tests/proof artifacts):** unit tests + протокол on-target/HIL измерений + фиксация результатов.

### 4.3 Критерий завершения этапа реализации
- Все пункты раздела 1.6 закрыты артефактами (лог, осциллограммы, отчёт тестов).

