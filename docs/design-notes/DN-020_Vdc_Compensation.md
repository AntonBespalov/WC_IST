# DN-XXX_Vdc_Compensation — Vdc feed-forward в fast loop (control_core)

Статус: **deferred (draft)**  
Дата: 2026-02-17  
Владелец: TBD  
Связано: `docs/decisions/ADR-009_Vdc_feed_forward_TK_vs_control_core.md`, `docs/PROJECT_CONTEXT.md`, `docs/GLOSSARY.md`, `docs/ENGINEERING_CONTRACT.md`, `docs/TEST_PLAN.md`, `docs/CONTEXT_SNAPSHOT.md`

**Триггер реализации / включения**: внедрять (и тем более включать) только после первых стендовых L3 измерений на железе, если подтверждено, что:
- при ступени/просадке Vdc наблюдается измеримое ухудшение качества регулирования (просадка `I_weld`, рост времени восстановления), и
- включение feed-forward даёт улучшение worst‑case без нарушения детерминизма/таймингов fast loop.

---

## 1) Context / Problem
- Требуется компенсировать просадку DC-link (Vdc) в PWM‑домене, чтобы реакция была на уровне следующего периода PWM, а не через 250 мкс цикл ТК.
- Контекст исполнения: fast loop в ISR/таймере (control_core), домен PWM.
- Источник измерения Vdc: поле `control_meas_t.udc` (см. `docs/PROJECT_CONTEXT.md` / раздел «Тайминги»).
- Инварианты:
  - fast loop остаётся O(1) без блокировок и без динамической памяти;
  - аппаратный shutdown‑path (TIM1 BKIN/BKIN2) не меняется;
  - протокол ТК не расширяется.

Примечание: без стендовых измерений и baseline метрик (jitter/WCET/просадка тока на Vdc‑ступенях) реализация не обязательна; данный DN фиксирует контракт алгоритма, чтобы при необходимости внедрить его быстро и без архитектурного дрейфа.

## 2) Goal / Non-goals
### Goal
- Зафиксировать контракт Vdc feed-forward как масштабирование управляющего воздействия **перед clamp**.
- Обеспечить устойчивость при валидном Vdc и безопасную деградацию при невалидном измерении.
- Сохранить детерминизм fast loop и отсутствие влияния на safety‑path.
- Гарантировать **backward-compatible** поведение: по умолчанию функция отключена и не меняет существующую динамику.

### Non-goals
- Не менять протокол обмена с ТК (250 мкс) и формат команд.
- Не менять частоту PWM, политику аварий и аппаратный shutdown‑path.
- Не переписывать регулятор, фильтры измерений или state machine.
- Не вводить авто‑рестарт после fault.

## 3) Decision (что делаем, когда будет триггер)
### 3.1 Алгоритм
В fast loop вводится коэффициент `vdc_factor` и масштабирование суммарного PI‑воздействия:

- `u_pi = u_p + u_i`
- `u_unsat_ff = u_pi * vdc_factor`
- `u_clamped = clamp(u_unsat_ff, u_min, u_max)`

**Важно (anti-windup):**
- решение о насыщении и о блокировке интегрирования принимается **по `u_unsat_ff`** (то есть с учётом Vdc‑масштабирования), чтобы интегратор не “боролся” с ограничениями, которые возникли именно из‑за просадки Vdc.

### 3.2 Включение/отключение (backward-compatible)
- Функция **отключена по умолчанию**: если `control_cfg_t.v_dc_nominal <= 0`, то `vdc_factor = 1.0` и поведение идентично baseline.

### 3.3 Валидность Vdc и безопасная деградация
- Если Vdc невалиден/слишком мал, используется `vdc_factor = 1.0`, управление продолжается по базовой логике.
- Источник “валидности” — `measurement_core`:
  - **предпочтительно** иметь/ввести отдельный признак качества для `udc` (например, `udc_valid` или quality‑flags);
  - если отдельного признака нет, то минимум: `meas_valid == true` **и** `isfinite(udc)` **и** `udc > vdc_min_valid`.

### 3.4 Ограничение коэффициента `vdc_factor`
Чтобы исключить выбросы на глитчах/шуме Vdc, коэффициент клипается:

- `vdc_factor_raw = v_dc_nominal / udc_measured`
- `vdc_factor = clamp(vdc_factor_raw, vdc_factor_min, vdc_factor_max)`

Дефолты (если не задано конфигурацией):
- `vdc_min_valid = 10 В`
- `vdc_factor_min = 0.25`
- `vdc_factor_max = 4.0`

### 3.5 Детерминизм
- Алгоритм остаётся O(1): сравнения + деление + умножение + 1–2 clamp.
- Никаких блокировок, аллокаций, лог‑форматирования в fast loop.

## 4) Rationale (почему так)
- В PWM‑домене можно компенсировать просадку Vdc за 1 период PWM, что недостижимо через 250 мкс цикл ТК.
- Решение не меняет протокол ТК и минимально влияет на архитектуру.
- CCM/DMA‑аспекты не затрагиваются: feed-forward применим только к CPU‑данным и не требует перемещения DMA‑буферов.
- Если contention/просадки не проявятся на железе, функция остаётся отключённой и DN не требует реализации.

## 5) Interfaces / Data / Timing impact
### Данные
- Используем `control_meas_t.udc` как `udc_measured`.
- Конфигурация (контракт):
  - `control_cfg_t.v_dc_nominal` [В], `<=0` → FF выключен;
  - опционально: `vdc_min_valid`, `vdc_factor_min`, `vdc_factor_max` (если не заданы — дефолты как выше).
- Внешние интерфейсы и протоколы не меняются. Внутренние флаги/диагностика могут отражать режимы: “FF active”, “Vdc invalid”, “factor clamped” (не обязательно для первой реализации, но полезно для отладки/логов).

### Тайминги
- Добавляются операции деления/умножения на период PWM; требуется измерить `fast_loop_wcet` и `fast_loop_jitter` и подтвердить отсутствие overruns.

## 6) Risks / Edge cases
- Невалидный Vdc (stuck/sat/timeout) может дать неверный коэффициент → обязательна деградация к `vdc_factor = 1.0` и опора на диагностику `measurement_core`.
- Шум Vdc может приводить к дрожанию duty → обязательны `vdc_min_valid` и клип `vdc_factor_min/max`; эффект насыщения фиксировать.
- Anti-windup:
  - если принимать решение о насыщении без учёта FF, интегратор может накапливаться/блокироваться “не вовремя” при изменениях Vdc.
- Ошибки чисел (NaN/Inf) → обязательные проверки `isfinite()` для `udc` и `vdc_factor`.

## 7) Test plan / Proof / Rollback
### Test plan / Proof
- Unit/host:
  - `v_dc_nominal <= 0` → `vdc_factor == 1.0`;
  - крайние значения: `udc=0`, `udc<10 В`, `udc=nominal`, `udc` сильно выше/ниже;
  - отсутствие NaN/Inf;
  - клип `vdc_factor` и `u_clamped` всегда в `u_min/u_max`;
  - проверка, что anti-windup реагирует на насыщение **после** FF (по `u_unsat_ff`).
- SIL (опционально, после появления модели):
  - “step Vdc drop” с проверкой восстановления тока не позднее 1–2 периодов PWM;
  - сравнение с baseline без компенсации.
- On-target (обязательно при триггере реализации):
  - ступенчатая просадка Vdc под нагрузкой, измерения `Vdc`, `duty`, `I_weld`;
  - измерить `fast_loop_wcet/jitter`;
  - инструментирование `DBG0/DBG1` (CTRL_TICK/PWM_APPLY), наблюдение `BKIN_RAW` и `PWM_OUT`;
  - по возможности логировать `vdc_factor`, `u_unsat_ff`, `u_clamped` (внутренний лог, без изменения протокола).
- HIL/bench (fault injection):
  1) `Vdc` stuck на 0 В;
  2) `Vdc` stuck на завышенном уровне;
  3) `Vdc` timeout/пропуски;
  4) шум `Vdc` 5–10%;
  5) ступени `Vdc` 10–20% при активной сварке.
  Ожидаемое: корректная деградация, отсутствие неконтролируемого роста duty, соблюдение safety‑инвариантов.

Критерии приёмки (для момента, когда будет триггер реализации):
- Восстановление `I_weld` после ступени Vdc: не позднее 1–2 периодов PWM (при валидном измерении).
- `fast_loop_wcet` и `fast_loop_jitter` не ухудшаются до уровня overruns (`cnt_ctrl_overrun` не растёт в нормальном режиме).
- При невалидном Vdc коэффициент = 1.0, отсутствуют NaN/Inf, поведение соответствует базовой логике.

### Rollback
- Отключить feed-forward конфигурационно: `v_dc_nominal <= 0` (эквивалент `vdc_factor = 1.0`), без изменения остального алгоритма.

## 8) Status / Implementation links
- Status: **deferred (draft)**
- Links: PR/commit/issue (TBD)
