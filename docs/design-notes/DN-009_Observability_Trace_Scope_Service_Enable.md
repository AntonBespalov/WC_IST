# DN-009_Observability_Trace_Scope_Service_Enable — Наблюдаемость (Trace/Scope) и включение сервиса по PCcom4

Статус: draft  
Дата: 2026-02-12  
Владелец: TBD  
Связано: docs/decisions/ADR-20260211-observability-trace-scope-and-service-enable.md, docs/PROJECT_CONTEXT.md, docs/design-notes/DN-008_AD7380_Sampling_and_Timing_Sync.md, docs/design-notes/DN-005_QSPI_PSRAM_Oscilloscope_Buffer.md, docs/protocols/PCCOM4.02_PROJECT.md  

---

## 1) Context / Problem
- Требуется наблюдаемость: коррелируемые по времени события/параметры и высокочастотные выборки АЦП.
- Есть два временных домена: fast PWM без RTOS и slow 1 мс в FreeRTOS.
- Fast-домен должен оставаться детерминированным: без UART/QSPI/сериализации/блокировок.
- Наблюдаемость не должна влиять на аппаратный shutdown-path (BKIN/DRV_EN/INH).
- Сервисный интерфейс: USB-UART (PCcom4); сервис по умолчанию выключен.
- Контекст исполнения: fast ISR/DMA (PWM/ADC), slow task (упаковка/отправка/запись).

## 2) Goal / Non-goals
### Goal
- Реализовать два потока:
  - `Trace`: события/параметры (kHz и ниже).
  - `Scope`: high-rate AD7380 (до 400 кГц), только окна pre/post-trigger.
- Буферизация: SPSC по контекстам; fast-контекст пишет O(1) в SRAM.
- Таймбаза: `timestamp_us` (u32, 1 МГц, wrap-around допустим) + `fast_seq` (HW-счётчик UEV от TIM1).
- Включение сервиса: `Service.Enable=ON` по PCcom4, действует до reset.
- Триггеры Scope: команда с ПК, fault, установка целевого тока с ТК.

### Non-goals
- Не менять контуры управления, пороговые защиты и аппаратный shutdown-path.
- Не делать “always-on” телеметрию/стриминг.
- Не менять транспорт сервиса (остаётся USB-UART/PCcom4).
- Не логировать high-rate выборки как `Trace` записи.

## 3) Decision (что делаем)
- Разделяем `Trace` и `Scope`.
- Буферизация: SPSC кольца по контекстам исполнения; merge/упаковка/CRC/отправка — только в slow task.
- `timestamp_us`: свободно бегущий 32-бит таймер 1 МГц (TIM2/TIM5), чтение разрешено в ISR как O(1).
- `fast_seq`: аппаратный счётчик UEV от TIM1 (через TRGO→ITR внешним тактом), 1 инкремент на полный PWM-цикл.
- В fast-контексте разрешены только:
  - чтение таймбазы,
  - запись в SRAM-буфер,
  - фиксация счётчиков drop.
- Сервис OFF по умолчанию; RX-парсер PCcom4 всегда активен и принимает `Service.Enable=ON`.

## 4) Rationale (почему так)
- SPSC по контекстам уменьшает джиттер и упрощает доказательство RT-ограничений.
- Разделение Trace/Scope предотвращает неправильное смешение данных разных классов.
- Гибрид `timestamp_us` + `fast_seq` обеспечивает корреляцию доменов без тяжелого упорядочивания на МК.
- Сервис “до reset” обеспечивает безопасный режим диагностики без постоянного обмена.

## 5) Interfaces / Data / Timing impact
### 5.1) Общие правила кодирования
- Endianess: все `u16/u32/i32` и массивы `u16` кодируются little-endian (как в `docs/protocols/PCCOM4.02_PROJECT.md`, если рядом явно не указано иначе).
- Выравнивание/паддинг:
  - на линии (PCcom4 `Scope.Data`) паддинг не используется, поля идут плотно;
  - во внутренних RAM-буферах допускается выравнивание до 4 байт для скорости записи, но это не должно “просачиваться” в wire-формат.
- Версионирование формата: каждое “семейство” данных (`Trace`, `Scope.Meta`, `Scope.Samples`) имеет `format_ver`, чтобы менять формат без двусмысленности.
- Корреляция времени: в каждом событии/блоке присутствуют `timestamp_us` [мкс] и `fast_seq` [-] (или `fast_seq0` для блока), как минимум для последующей склейки на ПК.

### 5.2) Trace — формат и упаковка
Назначение: события/параметры (kHz и ниже) от разных модулей, записываемые из fast/ISR/task в SPSC-буферы.

#### 5.2.1) `Trace.RecordV1` (логическая запись, без паддинга в wire-формате)
Поля:
- `timestamp_us` (`u32`, [мкс]) — монотонная таймбаза 1 МГц, wrap-around допустим.
- `fast_seq` (`u32`, [-]) — номер периода PWM (UEV), аппаратно синхронизирован с TIM1.
- `source_id` (`u8`, [-]) — идентификатор источника/модуля (таблица источников фиксируется отдельно; значения 0 запрещены).
- `event_id` (`u8`, [-]) — идентификатор события внутри `source_id`.
- `len` (`u8`, [байт]) — длина полезной нагрузки `payload`.
- `flags` (`u8`, [-]) — битовые флаги:
  - bit0: `IMPORTANT` (событие желательно не терять; при переполнении всё равно допускается drop, но счётчик обязателен),
  - bit1: `FROM_ISR` (запись сделана из ISR),
  - bit2..7: `reserved` (=0).
- `payload[len]` (`u8[]`) — полезные данные события (структура зависит от `source_id/event_id`).

Ограничения:
- Максимальный `len` должен быть ограничен проектно (TBD, рекомендация: 0..32 байта) для контроля worst-case времени записи и давления на SRAM.
- Для частых событий предпочтителен фиксированный payload, чтобы избежать ветвлений в fast-домене.

#### 5.2.2) Внутреннее хранение (SPSC)
- В fast/ISR допускается только “сериализация записи” в RAM и обновление `head` (commit) одним атомарным шагом без блокировок.
- Политика переполнения: запись отбрасывается (drop), инкрементируется `trace_dropped_total` и, опционально, `trace_dropped_important`.
- В каждом буфере должны быть водяные знаки (high-watermark) для диагностики запасов.

#### 5.2.3) Выдача на ПК (через PCcom4 `Node=0x06`, `Scope.Data`)
`Trace` передаётся “чанками” с несколькими `Trace.RecordV1` в одном PCcom4 сообщении.

Dataset: `Scope.Data` / `dataset_id = 0x01` (`Trace.ChunkV1`)
- `dataset_id` (`u8`) = `0x01`
- `format_ver` (`u8`) = `1`
- `record_count` (`u8`) — кол-во записей в чанке (1..N)
- `reserved_u8` (`u8`) = 0
- далее `record_count` записей `Trace.RecordV1`, упакованных подряд без паддинга

Примечание: если одна запись не помещается в `DataLen` PCcom4 кадра, она пропускается с инкрементом drop-счётчика (недопустимо фрагментировать одну запись без явного протокола фрагментации).

### 5.3) Scope — формат и упаковка
Назначение: высокочастотные “сырые” выборки АЦП (например AD7380 до 400 кГц) в виде окон pre/post-trigger. Формирование выборок выполняется DMA-блоками; сохранение в PSRAM и отправка по UART — только в slow task.

#### 5.3.1) Термины и параметры окна
- `fs_hz` — частота дискретизации [Гц] (например 400000).
- `pre_ms` — предыстория [мс] (требование: 5..10 мс).
- `post_ms` — послесобытийное окно [мс] (требование: 100..200 мс).
- `channels` — число каналов (1 или 2; для AD7380 типично 2: I_weld и U_weld).
- `sample_format` — формат сэмпла (в этой версии: `u16` на канал, без знака, как отдаёт АЦП).

#### 5.3.2) `Scope.MetaV1` (метаданные захвата)
Dataset: `Scope.Data` / `dataset_id = 0x10` (`Scope.MetaV1`)
Поля:
- `dataset_id` (`u8`) = `0x10`
- `format_ver` (`u8`) = `1`
- `capture_id` (`u16`, [-]) — идентификатор захвата (монотонный, wrap-around допустим).
- `reason` (`u8`, [-]) — причина триггера:
  - `1` = `HOST_CMD`,
  - `2` = `FAULT`,
  - `3` = `TK_SETPOINT`,
  - остальные значения зарезервированы.
- `flags` (`u8`, [-]):
  - bit0: `BEST_EFFORT` (захват выполнен частично),
  - bit1: `TRIGGERS_DROPPED_DURING_CAPTURE` (во время активного захвата были игнорированные триггеры),
  - bit2..7: `reserved` (=0).
- `t_trig_us` (`u32`, [мкс]) — `timestamp_us` в момент триггера.
- `fast_seq_trig` (`u32`, [-]) — `fast_seq` в момент триггера.
- `fs_hz` (`u32`, [Гц]) — фактическая частота дискретизации.
- `channel_count` (`u8`, [-]) — 1 или 2.
- `sample_bits` (`u8`, [бит]) — 16.
- `reserved_u16` (`u16`) = 0.
- `pre_samples` (`u32`, [samples/channel]) — число сэмплов до триггера на канал.
- `post_samples` (`u32`, [samples/channel]) — число сэмплов после триггера на канал.
- `dropped_triggers` (`u16`, [-]) — число триггеров, проигнорированных во время активного захвата (для этого `capture_id`).
- `reserved_u16_2` (`u16`) = 0.

Примечания:
- `pre_samples/post_samples` могут быть меньше номинала при `BEST_EFFORT` (например, из-за ошибки PSRAM/QSPI или ограничения буфера).
- Метаданные всегда отправляются первыми перед данными сэмплов для соответствующего `capture_id`.

#### 5.3.3) `Scope.SamplesU16V1` (пакеты сэмплов)
Dataset: `Scope.Data` / `dataset_id = 0x11` (`Scope.SamplesU16V1`)
Назначение: потоковая выгрузка сэмплов, фрагментированная по PCcom4 кадрам.

Поля:
- `dataset_id` (`u8`) = `0x11`
- `format_ver` (`u8`) = `1`
- `capture_id` (`u16`, [-])
- `sample_offset` (`u32`, [samples/channel]) — смещение первого сэмпла в общем массиве захвата (0 = первый pre-сэмпл).
- `sample_count` (`u16`, [samples/channel]) — количество сэмплов на канал в этом пакете.
- `channel_count` (`u8`, [-]) — 1 или 2 (дублируется для самодостаточности пакета).
- `reserved_u8` (`u8`) = 0
- далее payload сэмплов:
  - если `channel_count=1`: `s0, s1, ...` (`u16` little-endian)
  - если `channel_count=2`: интерливинг по времени: `I0, U0, I1, U1, ...` (`u16` little-endian)

Ограничения:
- `sample_count` выбирается так, чтобы пакет укладывался в лимит `DataLen` PCcom4 (2..246 байт) с учётом заголовка.
- Порядок пакетов: допускается отправка строго по возрастанию `sample_offset`; пропуски недопустимы без явного флага `BEST_EFFORT` в метаданных.

### 5.4) PCcom4 Service Enable (включение сервиса)
- По умолчанию сервис OFF: нет логирования, нет запуска Scope/DMA, нет TX по UART.
- Всегда активен только UART RX + лёгкий stream-парсер PCcom4, который принимает команду `Service.Enable=ON`.
- `Service.Enable=ON` действует до reset (одноразовая debug-сессия).

### 5.5) Тайминги и совместимость
- Тайминги:
  - fast-контекст: только O(1) операции, никаких UART/QSPI/CRC.
  - обязательные on-target измерения джиттера в режимах OFF/ON.
- Обратная совместимость:
  - базовый PCcom4 фрейминг сохраняется, расширения фиксируются в проектном профиле (`docs/protocols/PCCOM4.02_PROJECT.md`).

## 6) Risks / Edge cases
- Переполнение Trace/Scope → drop + счётчики (видимость через сервис).
- Ошибка QSPI/PSRAM → Scope деградирует, без влияния на сварку.
- Повторный триггер во время захвата → ignored, `dropped_triggers++`, фиксируется причина.
- Ошибка/рассинхронизация PCcom4 → CRC-ошибки и ресинхронизация.

## 7) Test plan / Proof / Rollback
### Test plan / Proof
- Unit/host:
  - SPSC ring-buffer: push/pop, wrap-around, переполнение, счётчики drop.
  - Scope state machine: IDLE → CAPTURING_POST → READY/UPLOAD; игнор триггеров.
  - PCcom4 RX-парсер: `Service.Enable` + CRC/ресинхронизация.
- SIL:
  - (если применимо) эмуляция нагрузки fast-пути с включённой наблюдаемостью, проверка отсутствия блокировок.
- On-target измерения (GPIO/осциллограф/trace):
  - длительность и джиттер fast-цикла при OFF и ON (Trace/Scope).
  - подтверждение `fast_seq` = 1 инкремент на полный PWM-цикл.
  - проверка монотонности `timestamp_us`, корректность wrap-around.
  - throughput PSRAM (QSPI) и USB-UART.
- HIL/bench:
  - длительный прогон с активным Scope и проверкой отсутствия влияния на управление.
  - best-effort capture при fault, даже при аппаратном выключении.

**Fault-injection (минимум 5):**
1) Переполнение Trace-буфера → drop-счётчик растёт, fast-путь не блокируется.  
2) Переполнение Scope-буфера → dropped_triggers++ и корректное состояние.  
3) Ошибка QSPI/PSRAM → Scope отключается/деградирует без влияния на сварку.  
4) PCcom4 CRC-ошибки/разрыв → ресинхронизация, счётчики ошибок.  
5) Reset/обрыв связи во время выгрузки Scope → безопасный reset, сервис OFF после перезапуска.  
6) Триггер во время активного захвата → игнор триггера, фиксируется причина.  

**Инструментирование:**
- GPIO: `CTRL_TICK`, `ADC_START`, `ADC_READY`, `PWM_APPLY`, `TRACE_PUSH`, `SCOPE_DMA_DONE`, `FAULT_ENTRY`.
- Обязательные наблюдения: `BKIN_RAW`, `PWM_OUT`, UART TX/RX.

### Rollback
- Отключить наблюдаемость флагом/конфигурацией сборки и/или оставить только RX-парсер `Service.Enable`.
- Откатить изменения `docs/protocols/PCCOM4.02_PROJECT.md` при необходимости.

## 8) Status / Implementation links
- Status: draft
- Links: PR/commit/issue
