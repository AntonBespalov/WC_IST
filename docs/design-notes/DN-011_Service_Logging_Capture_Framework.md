# DN-TBD_Service_Logging_Capture_Framework — Гибкая архитектура логгирования/осциллографирования через FT232H (PCcom4)

Статус: draft  
Дата: 2026-02-14  
Владелец: Антон  
Связано: `docs/ARCHITECTURE.md`, `docs/PROJECT_CONTEXT.md`, `docs/protocols/PCCOM4.02.md`, `docs/decisions/ADR-004_TK_Interface_EtherCAT_COMX_FMC_and_UART_PDO_Emu.md`  
Практическая интеграция и порядок вызовов: `docs/logging/LOGGING_GUIDE.md`  

---

## 1) Context / Problem
Нужно организовать эффективное и корректное логгирование/выгрузку данных для анализа через сервисный интерфейс (FT232H + PCcom4):
- (A) на время отсутствия полноценного EtherCAT со стороны ТК — обмениваться «эмуляцией PDO» поверх PCcom4 (для имитации управления/обратной связи);
- (B) выгружать внутренние переменные контура управления (для отладки/настройки);
- (C) выгружать сырые данные АЦП (прежде всего AD7380), но не обязательно постоянным стримом — важнее захват окна «до/во время/после» сварки.

Контекст исполнения:
- **PWM-домен 1–4 кГц** (fast loop) — детерминированный, без RTOS;
- **slow loop на FreeRTOS** — протокол/диагностика/логирование/сервис.
Нельзя ухудшить детерминизм fast loop и путь безопасного отключения (BKIN/BKIN2). Наблюдаемость является частью архитектуры (см. принципы наблюдаемости/record-replay).

---

## 2) Goal / Non-goals
### Goal
1) Сформировать **единый каркас телеметрии** (records + команды управления), который работает на этапе-1 (SRAM-only) и расширяется на этапе-2 (PSRAM/QSPI) **без переделки producers и протокола**.
2) Обеспечить **расширяемость по источникам** (легко добавлять новые producers: прореженные токи/напряжения/температуры и т.п.).
3) Обеспечить **управляемые наборы данных** (особенно для `CTRL`): выбор профиля/каналов/частоты без «размазывания» `store_write()` по коду регулятора.
4) Обеспечить корректность по RT:
   - в fast loop только минимальные, ограниченные по времени операции (snapshot + publish);
   - форматирование/упаковка/CRC/транспорт/запись во внешнюю память — только в slow loop.
5) Обеспечить диагностируемость: counters/overrun/dropped/incomplete capture как часть статуса.

### Non-goals
- Не проектируем здесь сервисное ПО на ПК (GUI/хранилище/визуализация) — только контракт протокола/данных.
- Не фиксируем «идеальный» набор переменных контура навсегда — задаём механизм профилей/каналов.
- Не делаем постоянный непрерывный стрим сырого AD7380 на максимальной частоте как обязательный режим (для этого может быть узким местом UART).
- Не определяем здесь окончательные пороги/политики fault-эскалации (это отдельные DN/Spec).

---

## 3) Decision (что делаем)

### 3.1. Единая модель данных: Record + Session
Вводим бинарный формат **Record** (единица логгирования) и концепцию **Capture Session** (сессия захвата с окнами pre/post trigger).

Record содержит:
- `magic` (0xA55A, в начале заголовка, для ресинхронизации),
- `type` (PDO / CTRL / ADC_RAW / SLOW_MEAS / META / …),
- `source_id`,
- `len`,
- `timestamp` (привязанный к PWM-домену: `pwm_period_count` + опц. subtick),
- `seq` (для диагностики потерь/перестановок),
- `payload`,
- опционально `crc` (считается/проверяется в slow loop).

Сессия захвата:
- имеет `session_id`,
- хранит `meta` (частоты, decimation, список каналов/профиль, длительность окна),
- содержит последовательность Record’ов, доступную для чтения чанками,
- реализует **pre/post trigger** без копирования данных: продюсер пишет в кольцо по кругу; при `TRIGGER` фиксируются указатели/смещения окна (например `wptr_trigger`, `wptr_end`), а запись продолжается только до завершения `post` части,
- чтение `LOG_READ_CHUNK(session_id, offset, max_len)` возвращает **линейное представление окна** (МК сам «линеаризует» wrap-around кольца), чтобы сервисное ПО не обязано было понимать внутреннюю топологию буферов.

### 3.2. Producer Registry (плагинная расширяемость)
Все источники данных реализуются как **producers**, регистрируются в реестре и не требуют изменений чужого кода.

Минимальный контракт producer:
- `describe()` → метаданные источника и (если применимо) каналы (id/единицы/scale).
- `configure(cfg)` → enable/disable, частота/децимация, профиль/список каналов.
- `on_tick_*()` / `on_event()` → точки съёма (PWM tick / 1ms tick / событие).
- `emit(snapshot/record_descriptor)` → публикация в LogCore.

Требования к реестру:
- регистрация продюсеров — **статическая** (таблица/линкер-секции), без `malloc` и без динамического изменения состава во время работы;
- задаются жёсткие лимиты (`MAX_PRODUCERS`, `MAX_CHANNELS_PER_SOURCE`, `MAX_SELECTED_CHANNELS`), чтобы конфигурация с ПК не могла «включить всё» и уронить RT.

Добавление нового источника (например, «прореженные температуры/входные токи/напряжения» с AD7606) = новый модуль producer + регистрация в таблице реестра.

### 3.3. Snapshot → Packer → Storage/Transport (чтобы не «мазать» лог по коду)
Для источника `CTRL` (и аналогичных) используем паттерн:
- в fast loop формируется **фиксированный snapshot-struct** (`CtrlSnapshot`) в одной точке (например, в конце control_tick);
- snapshot публикуется в SRAM SPSC ring **только если** включён соответствующий режим логгирования;
- в slow loop **packer** выбирает набор полей (профиль/каналы) и упаковывает в Record’ы для хранения/передачи.
Требование консистентности:
- `CtrlSnapshot` снимается **в одной фиксированной точке периода PWM** (например, в конце `control_tick` после обновления duty/лимитов), чтобы поля были согласованы;
- если часть полей обновляется в разных ISR/доменах, используется double-buffer состояния (`CtrlState` ping-pong) и атомарное переключение указателя раз в период.


Таким образом:
- fast loop не содержит `store_write()` и не знает про профили;
- управление набором данных реализуется конфигурацией packer’а.

### 3.4. Backends хранения (этапность без смены протокола)
**Этап-1 (SRAM-only):**
- `STORE_SRAM`: кольцевые буферы (SPSC) + freeze на capture; маленькие окна ADC_RAW.
- `STREAM_UART`: live stream для PDO/CTRL (с ограничением полосы), выгрузка capture по запросу чанками.

**Этап-2 (QSPI PSRAM):**
- добавляется `STORE_PSRAM` как долгий буфер (file-like), а SRAM остаётся как staging/pretrigger.
- запись в PSRAM выполняется короткими транзакциями (chunked writes) с соблюдением ограничения tCEM (Chip Select Low Time) конкретной PSRAM.
- верхний протокол и producers не меняются.

### 3.5. Протокол управления логгером поверх PCcom4
Добавляем/фиксируем командный набор (поверх PCcom4):
- `LOG_LIST_SOURCES`, `LOG_LIST_CHANNELS(source_id)`;
- `LOG_SET_SOURCE_ENABLE(source_id, en)`;
- `LOG_SET_RATE(source_id, decimation_or_hz)`;
- `LOG_SET_PROFILE(source_id, profile_id)` (минимум для CTRL/SLOW_MEAS);
- (опц., этап-2) `LOG_SET_CHANNEL_MASK(source_id, channel_id[])`;
- `LOG_ARM(session_cfg)`, `LOG_TRIGGER(reason)`, `LOG_STOP()`, `LOG_CLEAR()`;
- `LOG_GET_STATUS()` (including overrun/dropped/incomplete);
- `LOG_GET_META(session_id)`;
- `LOG_READ_CHUNK(session_id, offset, max_len)` → возвращает кусок bytes.


### 3.6. Арбитраж трафика и квотирование полосы (чтобы логи не «забили» PDO)
Так как PDO-эмуляция и логи идут по одному физическому каналу (FT232H), транспорт обязан обеспечивать **жёсткий приоритет** управляющего обмена.

Правила транспорта (slow loop):
- две независимые очереди/потока на отправку: `TX_PDO` и `TX_LOG` (не один общий FIFO);
- если в `TX_PDO` есть кадры — отправлять их **первее** логов;
- логи отправлять только когда канал свободен и нет ожидающих PDO.

Дополнительно вводится **квотирование полосы** для логов (token bucket/байтовый бюджет), например:
- за каждый 250 мкс тик (4 кГц) начислять `log_budget_bytes` (частота тика должна соответствовать `logging_tx_scheduler`),
- отправка логов возможна только пока бюджет положительный,
- бюджет не влияет на `TX_PDO`.

Этим гарантируется, что даже при ошибочной конфигурации источников/частот логи не нарушат тайминги PDO и не приведут к ложным таймаутам управления.

---

## 4) Rationale (почему так)

1) **RT-инварианты (fast loop) важнее логов.**  
   Snapshot+publish (минимальная ветка) сохраняет детерминизм. Упаковка/CRC/передача/внешняя память — всегда вне fast loop.

2) **Расширяемость через реестр producers.**  
   Это предотвращает «архитектурное разрастание» (ещё один switch в 5 местах) и облегчает добавление новых измерений (AD7606 температуры/входные фазы и т.д.).

3) **Профили/каналы через packer, а не через бизнес-логику.**  
   Регулятор остаётся чистым, а выбор набора данных/частоты — настраиваемый.

4) **Единый протокол чтения чанками.**  
   UART/FT232H — ограниченная полоса. Read-by-chunks позволяет:
   - гарантировать приоритет управляющих сообщений (PDO emu),
   - избегать перегрузки и не мешать управлению.

5) **Этапность через backend storage.**  
   На этапе-1 можно начать без PSRAM и получить пользу (PDO emu + CTRL + короткие raw-окна).  
   На этапе-2 добавляется PSRAM для длинных окон, не меняя producers/формат/PC-команды.

Отклонённые варианты:
- «Писать сырые ADC непрерывно сразу в UART» — риск перегрузки полосы и влияния на RT.
- «Вставлять store_write() в код регулятора для каждой переменной» — шум, сложность, риск недетерминизма и сложное расширение.

---

## 5) Interfaces / Data / Timing impact

### 5.1. Размещение в архитектуре модулей
Рекомендуемая привязка к существующим слоям:
- `logging_hal` (Platform/HAL): UART DMA, QSPI PSRAM driver, timebase hooks.
- `protocol_core`: PCcom4 команды логгера и сериализация/десериализация control-пакетов.
- `diag_counters`: counters dropped/overrun/latency.
- producers для измерений/контроля — на границе fast loop (publish) и slow loop (pack).

### 5.2. Точки съёма (timing domains)
- `PDO` producer: в домене 250 мкс (4 кГц) или 1 мс (в зависимости от режима эмуляции и доступности данных).
- `CTRL` producer: раз в период PWM (1–4 кГц), с программной децимацией.
- `ADC_RAW` producer: по DMA complete от SPI/таймера, блоками; по умолчанию только capture-окна.
- `SLOW_MEAS` producer (будущий): 10–1000 Гц (температуры/входные токи/напряжения).

### 5.3. Ограничение tCEM для PSRAM (этап-2)
PSRAM backend обязан:
- ограничивать длительность удержания CS low (tCEM) за одну транзакцию;
- писать/читать короткими чанками фиксированного размера (`psram_max_payload_bytes`), заданного консервативно или вычисленного из SCLK;
- обеспечивать минимальное CS high (tCPH), если требуется.

### 5.4. Совместимость и версионирование
- В `META` Record включить `log_format_version`.
- В командах `LOG_GET_META` возвращать версию и параметры, чтобы сервисное ПО могло парсить корректно.
- Все multi-byte поля в payload и заголовках — **Little Endian** (LE) по умолчанию.
- Идентификаторы `source_id`/`channel_id` являются стабильными (не переиспользуются для другой семантики) — изменения делаются через увеличение версии формата.

---

## 6) Risks / Edge cases

1) **Переполнение SRAM-буферов (этап-1).**  
   Митигируем: per-source counters `dropped`, флаг `overrun`, deterministic policy (drop-oldest для pretrigger, drop-newest/oldest по роли источника).

2) **Перегрузка UART (live stream).**  
   Митигируем: квотирование bandwidth, приоритет PDO emu, ограничение частоты CTRL и запрет/децимация ADC_RAW live.

3) **Нарушение tCEM при PSRAM записи (этап-2).**  
   Митигируем: строгий chunked write/read; запрет длинных memory-mapped write потоков; тест на осциллографе CS.

4) **Непредсказуемые задержки из-за блокировок.**  
   Митигируем: SPSC ring между ISR→task, отсутствие mutex в fast контуре; минимизация критических секций.

5) **Смешение таймбаз разных доменов.**  
   Митигируем: timestamp в единицах PWM-period (и/или микросекунды с явной привязкой), документирование.

6) **Потеря целостности сессии при reset/fault.**  
   Митигируем: `session_state`, признак `incomplete`, запись META в начале/в конце, counters.

---

## 7) Test plan / Proof / Rollback

### Test plan / Proof
- Unit/host:
  - тесты SPSC ring (FIFO order, overflow policy, wrap-around);
  - тесты packer (профили/списки каналов → корректная упаковка records);
  - тесты сериализации PCcom4 команд логгера (round-trip).
- SIL:
  - record/replay для `CTRL` и `PDO`: воспроизведение управляющих сценариев и сравнение выходов (duty/state/fault).
  - проверка, что dropped/overrun корректно отражается в статусе.
- On-target измерения (GPIO/осциллограф/trace):
  - измерить время `control_tick` и джиттер до/после включения логгера (логгер не должен ломать бюджет);
  - измерить латентность SPI DMA complete → publish;
  - проверить стабильность UART DMA (без блокировок) и приоритет PDO emu.
- HIL/bench:
  - тест «fault во время capture»: корректный safe-state (BKIN) независимо от логгера, сессия помечается incomplete;
  - проверка корректного окна pre/post trigger на реальном сигнале.

Этап-2 дополнительно:
- On-target: измерить длительность CS low на PSRAM при write/read чанках (доказать соблюдение tCEM).
- Нагрузочный тест: длительный capture на PSRAM + параллельный PDO emu без деградации управления.

### Rollback
- Возможность сборки с флагом `LOGGING_ENABLE=0` (компиляционная опция) для быстрой изоляции проблем.
- Runtime: команда `LOG_SET_SOURCE_ENABLE(all, 0)` и `LOG_CLEAR()` — мгновенно снижает нагрузку.
- При обнаружении overrun в fast домене: перевод логгера в режим «только counters» (без записи) до конца цикла/сессии.

---

## 8) Status / Implementation links
- Status: draft
- Implementation (stage-1, SRAM-only): `Fw/logging/` (core + SRAM capture + packer + TX scheduler)
- Example usage: `Fw/logging/README.md`
- Unit tests (L1): `tests/unit/logging_framework_tests.c`
