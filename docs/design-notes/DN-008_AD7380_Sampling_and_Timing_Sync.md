# DN-008 — Синхронизация PWM/таймбазы и выборок AD7380 (для Trace/Scope)

Статус: draft  
Дата: 2026-02-12  
Владелец: TBD  
Связано: `docs/PROJECT_CONTEXT.md` (тайминги/PWM/измерения), `docs/decisions/ADR-20260211-observability-trace-scope-and-service-enable.md` (наблюдаемость), `docs/design-notes/DN-005_QSPI_PSRAM_Oscilloscope_Buffer.md` (буфер осциллографа)  

---

## 1) Context / Problem
- Система имеет два временных домена: fast (1 раз на период PWM, без RTOS) и slow (1 мс, FreeRTOS). Требуется коррелируемая по времени наблюдаемость (Trace/Scope) и понятная схема синхронизации измерений AD7380 относительно PWM.
- Требования к наблюдаемости: не ухудшать детерминизм fast домена, не участвовать в shutdown-path (BKIN/DRV_EN), все тяжёлые операции (UART/QSPI/упаковка/CRC) — только в slow task.

## 2) Goal / Non-goals
### Goal
- Зафиксировать **таймбазу** и **привязку к PWM** для меток времени, используемых в Trace/Scope.
- Зафиксировать **схему выборок AD7380** (события/частоты/окна/буферы/DMA) так, чтобы её можно было:
  - реализовать без блокировок в fast/ISR,
  - проверить on-target измерениями (GPIO/осциллограф/trace),
  - использовать на ПК для корреляции и анализа.

### Non-goals
- Не фиксировать в этом документе формат протокола PCcom4 (это в `docs/protocols/PCCOM4.02_PROJECT.md`).
- Не описывать полностью алгоритмы управления/защит (это в профильных DN/ADR по control/safety).

## 3) Принятые решения (из ADR) — база
Источник: `docs/decisions/ADR-20260211-observability-trace-scope-and-service-enable.md`.

- `timestamp_us`: монотонная timebase в микросекундах (u32, wrap-around допустим) от отдельного free-running 32-бит таймера (TIM2/TIM5) с частотой 1 МГц.
- TIM1: режим center-aligned; `TIM1.RCR=1` для Update/UEV 1 раз на полный PWM-цикл (up+down).
- `fast_seq`: номер периода PWM, формируемый аппаратно как счётчик Update/UEV от `TIM1 TRGO=Update` (не через инкремент в ISR).
- (Опционально) `pwm_phase_ticks`: `TIM1.CNT` + направление (DIR) для фазовой привязки “внутри периода”, если потребуется.

## 4) Схема выборок AD7380 (Draft 0.2 — фазосинхронная сетка по периоду PWM)
Ниже — **предлагаемая** схема выборок, согласованная с ограничениями RT/safety из ADR (в fast/ISR только O(1) работа в SRAM; никакого UART/QSPI). Схема обеспечивает:
- повторяемую фазу выборок относительно периода PWM;
- формирование “средних по периоду PWM” (см. `docs/PROJECT_CONTEXT.md` / инвариант измерений);
- возможность включать “Scope” (pre/post окна) без влияния на shutdown-path.

### 4.1) Предпосылки/assumptions (явные)
- AD7380 подключён по SPI+DMA; чтение результатов не требует busy-wait в fast/ISR.
- Есть сигнал запуска конверсии AD7380 (условно `CNV`), который можно формировать таймером.
- AD7380 имеет пайплайн: на шаге `k` сигнал `CNV` запускает конверсию `k`, а по SPI читается результат `k-1` (первое чтение после старта — “прогревочное/пустое” и должно обрабатываться отдельно).
- Кол-во выборок на полный PWM-цикл: `N` (целое). Шаг сетки: `Δt = T_pwm / N`, частота выборок: `f_s = N * f_pwm`. Требование: `f_s` не превышает возможности тракта AD7380+SPI (ориентир: до 400 кГц, см. ADR).
- При fault (PWM может быть выключен аппаратно) сбор post делается best-effort: запись в буферы может продолжаться, но не должна влиять на safety.

### 4.2) Тайминг-диаграмма (ASCII, зафиксировать как “reference”)
**Полный PWM-цикл (TIM1 center-aligned, `RCR=1`)**:
```text
Время →
0                                                           T_pwm

TIM1 counter:
0 → → → → → ARR → → → → → 0   (up-down, полный цикл)

TIM1 PWM (плечо):
        ┌───────┐        ┌───────┐
────────┘       └────────┘       └────────

TIM1 Update (RCR=1):
↑                                                       ↑
|<------------------- 1 полный PWM период ------------->|
```

**Семплинг-сетка: `TIM_SAMPL` reset от TIM1 Update (пример: `N=8`)**:
```text
Δt = T_pwm / N

TIM_SAMPL sampling ticks:

0      1·Δt    2·Δt    3·Δt    4·Δt    5·Δt    6·Δt    7·Δt    T_pwm
|------|------|------|------|------|------|------|------|

↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑
S0     S1     S2     S3     S4     S5     S6     S7
```

**Один шаг семплирования `k` (пайплайн AD7380)**:
```text
t = k·Δt

TIM_SAMPL tick:
        ↑

CNV (импульс):
        ┌─┐
────────┘ └────────────────────────

AD7380:
        [ Sample & Convert ]
        |<---- t_conv ---->|

SPI DMA (чтение предыдущего результата):
              ┌──────────────┐
──────────────┘              └──────────────

На шаге k:
- CNV запускает конверсию k
- SPI читает результат k-1
```

**Совмещённая диаграмма (концепт)**:
```text
TIM1 PWM:
        ┌───────┐        ┌───────┐
────────┘       └────────┘       └────────

TIM1 Update:
↑                                                       ↑

TIM_SAMPL ticks:
↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑
S0     S1     S2     S3     S4     S5     S6     S7

CNV pulses:
┌─┐    ┌─┐    ┌─┐    ┌─┐    ┌─┐    ┌─┐    ┌─┐    ┌─┐
┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────

SPI read (DMA):
      ████      ████      ████      ████      ████
```

### 4.3) Роли таймеров и событий (без привязки к конкретным инстансам)
**Шаг 1 — PWM период / `fast_seq`**
- TIM1: center-aligned; `RCR=1` (1 Update/UEV на полный up+down цикл).
- `fast_seq`: аппаратный счётчик `TIM1 TRGO=Update` (см. ADR), читается O(1).

**Шаг 2 — Семплинг-сетка `N` точек на период**
- `TIM_SAMPL`: таймер семплирования, работающий в slave/reset mode от `TIM1 TRGO=Update`.
- `TIM_SAMPL` генерирует события с шагом `Δt = T_pwm / N` и формирует импульс `CNV` (через PWM-выход/OC toggle/One-pulse — конкретный способ фиксируется при реализации).

### 4.4) DMA/буферы и вычисление “средних по периоду”
**Данные**
- На каждом tick `k` запускается CNV, а DMA читает результат `k-1` (пайплайн).
- В SRAM хранится массив из `N` пар (`I[k]`, `U[k]`) на полный PWM-цикл + метаданные (`fast_seq`, `t0_us`).

**Расчёт средних (в конце периода, TIM1 Update/UEV)**
```text
I_per = mean(I[0..N-1])
U_per = mean(U[0..N-1])
P_per = mean(I[k] * U[k])
```
Примечание: вычисления “средних” выполняются в том домене/контексте, где это укладывается в бюджет времени (в fast — только если доказано измерениями; иначе — в slow с переносом массива/агрегатов).

### 4.5) Scope (pre/post окна) поверх этой схемы
- Для Scope блоки данных естественно формировать “пакетами” по нескольким PWM-периодам: `block_periods` периодов ⇒ `block_samples = block_periods * N` выборок на канал.
- Pre-trigger: кольцо последних `pre_ms` в SRAM (в блоках).
- Post-trigger: дозапись `post_ms`, затем READY/UPLOAD.

### 4.6) Что обязательно уточнить при переходе к реализации
- Как формируется `CNV` и соблюдается ли требуемая длительность/форма импульса.
- `t_conv` AD7380 и временные ограничения SPI-обмена (чтобы SPI чтение не конфликтовало по времени с новой конверсией).
- Как обновляется `N`/`Δt` при смене `f_pwm` (если PWM частота изменяемая в диапазоне 1–4 кГц).
- Точный формат “1 sample” в DMA (2×u16 vs u32) и порядок каналов.
- Лимит прерываний DMA (half/full) и измеренный вклад в джиттер fast домена.

## 5) Proof / Measurements (минимум)
- On-target:
  - подтвердить, что чтение `timestamp_us` и запись метаданных блока DMA укладываются в O(1) и не увеличивают джиттер fast loop;
  - подтвердить, что `fast_seq` соответствует 1 инкременту на полный PWM-цикл (с учётом center-aligned + `RCR=1`);
  - подтвердить, что запуск/окна AD7380 совпадают со схемой (GPIO метки + осциллограф).

## 6) Open questions
- Какой именно таймер выбран под `timestamp_us`, а какой под `fast_seq` (TIM2 vs TIM5) с учётом занятости периферии?
- Нужна ли фазовая привязка `pwm_phase_ticks` для целей анализа, или достаточно (`fast_seq`, `timestamp_us`)?
- Какой источник события триггера для AD7380 обеспечивает требуемую повторяемость и минимальный джиттер?
