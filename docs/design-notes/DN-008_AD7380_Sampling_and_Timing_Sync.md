# DN-008 — Синхронизация PWM/таймбазы и выборок AD7380 (для Trace/Scope)

Статус: draft  
Дата: 2026-02-13  
Владелец: TBD  
Связано: `docs/PROJECT_CONTEXT.md` (тайминги/PWM/измерения), `docs/decisions/ADR-005_Observability_Trace_Scope_and_Service_Enable.md` (наблюдаемость), `docs/decisions/ADR-006_AD7380_TIM3_DMA_Sampling.md` (семплирование AD7380), `docs/design-notes/DN-005_QSPI_PSRAM_Oscilloscope_Buffer.md` (буфер осциллографа)  

---

## 1) Context / Problem
- Система имеет два временных домена: fast (1 раз на период PWM, без RTOS) и slow (1 мс, FreeRTOS). Требуется коррелируемая по времени наблюдаемость (Trace/Scope) и понятная схема синхронизации измерений AD7380 относительно PWM.
- Требования к наблюдаемости: не ухудшать детерминизм fast домена, не участвовать в shutdown-path (BKIN/DRV_EN), все тяжёлые операции (UART/QSPI/упаковка/CRC) — только в slow task.

## 2) Goal / Non-goals
### Goal
- Зафиксировать **таймбазу** и **привязку к PWM** для меток времени, используемых в Trace/Scope.
- Зафиксировать **схему выборок AD7380** (события/частоты/окна/буферы/DMA) так, чтобы её можно было:
  - реализовать без блокировок в fast/ISR,
  - проверить on-target измерениями (GPIO/осциллограф/trace),
  - использовать на ПК для корреляции и анализа.

### Non-goals
- Не фиксировать в этом документе формат протокола PCcom4 (это в `docs/protocols/PCCOM4.02_PROJECT.md`).
- Не описывать полностью алгоритмы управления/защит (это в профильных DN/ADR по control/safety).

## 3) Принятые решения (из ADR) — база
Источник: `docs/decisions/ADR-005_Observability_Trace_Scope_and_Service_Enable.md`.

- `timestamp_us`: монотонная timebase в микросекундах (u32, wrap-around допустим) от отдельного free-running 32-бит таймера (TIM2/TIM5) с частотой 1 МГц.
- TIM1: режим center-aligned; `TIM1.RCR=1` для Update/UEV 1 раз на полный PWM-цикл (up+down).
- `fast_seq`: номер периода PWM, формируемый аппаратно как счётчик Update/UEV от `TIM1 TRGO=Update` (не через инкремент в ISR).
- (Опционально) `pwm_phase_ticks`: `TIM1.CNT` + направление (DIR) для фазовой привязки “внутри периода”, если потребуется.

## 4) Схема выборок AD7380 (по ADR-006 — TIM3 PWM(CS) + TIM3_UP→DMA→SPI)
Ниже — схема выборок **как источник правды по механике семплирования** (см. `docs/decisions/ADR-006_AD7380_TIM3_DMA_Sampling.md`), согласованная с ограничениями RT/safety из ADR по наблюдаемости (в fast/ISR только O(1) работа в SRAM; никакого UART/QSPI). Схема обеспечивает:
- повторяемую фазу выборок относительно периода PWM;
- формирование “средних по периоду PWM” (см. `docs/PROJECT_CONTEXT.md` / инвариант измерений);
- возможность включать “Scope” (pre/post окна) без влияния на shutdown-path.

### 4.1) Предпосылки/assumptions (явные)
- AD7380 работает в 2-wire режиме; выборка/кадрирование формируется окном `CS` и 16 тактами `SCK` внутри этого окна (конкретика — см. ADR-006).
- SPI1 — master, тактирует `SCK` и читает `SDO_A`; SPI2 — slave, синхронно читает `SDO_B` (через аппаратные перемычки `SCK` и `NSS`).
- На частоте семплирования `f_s=400 кГц` CPU-overhead на каждый семпл = 0 (все транзакции запускаются DMA/таймером); допускаются только редкие события уровня “конец блока” (half/full) в контексте, который не ломает fast домен.
- Кол-во выборок на период PWM: `N=100` при `f_pwm=4 кГц` → `T_pwm=250 мкс` → `Δt=2.5 мкс`.
- При fault (PWM может быть выключен аппаратно) сбор post делается best-effort: запись в буферы может продолжаться, но не должна влиять на safety/shutdown-path.

### 4.2) Тайминг-диаграмма (ASCII, зафиксировать как “reference”)
**Полный PWM-цикл (TIM1 center-aligned, `RCR=1`)**:
```text
Время →
0                                                           T_pwm

TIM1 counter:
0 → → → → → ARR → → → → → 0   (up-down, полный цикл)

TIM1 PWM (плечо):
        ┌───────┐        ┌───────┐
────────┘       └────────┘       └────────

TIM1 Update (RCR=1):
↑                                                       ↑
|<------------------- 1 полный PWM период ------------->|
```

**Семплинг-сетка: TIM3 reset от TIM1 Update (пример: `N=8`)**:
```text
Δt = T_pwm / N

TIM3 sampling ticks (Update events):

0      1·Δt    2·Δt    3·Δt    4·Δt    5·Δt    6·Δt    7·Δt    T_pwm
|------|------|------|------|------|------|------|------|

↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑
S0     S1     S2     S3     S4     S5     S6     S7
```

**Один шаг семплирования `k` (CS-кадр + 16 SCK внутри окна)**:
```text
t = k·Δt

TIM3_UP:
        ↑

CS (TIM3 CH2, active LOW):
        ┌──────────────┐
────────┘              └──────────────
         |<-- окно CS -->|

DMA → SPI1->TXDR (dummy word):
         █

SCK (SPI1, 16 pulses):
         ████████████████

SPI1_RX DMA (SDO_A) и SPI2_RX DMA (SDO_B):
         █ (по 1 слову на интерфейс)

На шаге k:
- DMA запускает SPI1 кадр ровно в начале окна CS-LOW
- SPI1/SPI2 DMA принимают по одному 16-бит слову (канал A/B)
```

**Совмещённая диаграмма (концепт)**:
```text
TIM1 PWM:
        ┌───────┐        ┌───────┐
────────┘       └────────┘       └────────

TIM1 Update:
↑                                                       ↑

TIM3_UP:
↑      ↑      ↑      ↑      ↑      ↑      ↑      ↑
S0     S1     S2     S3     S4     S5     S6     S7

CS (active LOW):
┌──┐   ┌──┐   ┌──┐   ┌──┐   ┌──┐   ┌──┐   ┌──┐   ┌──┐
┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───

SCK bursts (16 pulses inside CS):
      ████      ████      ████      ████      ████
```

### 4.3) Роли таймеров и событий (конкретизация по ADR-006)
**Шаг 1 — PWM период / `fast_seq`**
- TIM1: center-aligned; `RCR=1` (1 Update/UEV на полный up+down цикл).
- `fast_seq`: аппаратный счётчик `TIM1 TRGO=Update` (см. ADR), читается O(1).

**Шаг 2 — Семплинг-сетка `N` точек на период (AD7380)**
- TIM1 → TRGO(Update) → TIM3 slave reset mode (синхронизация начала PWM периода: TIM3 `CNT=0`).
- TIM3:
  - `f_s = 400 кГц` (при `f_pwm=4 кГц` и `N=100`).
  - CH2 = PWM Generation: формирует `CS` (active LOW) с окном, достаточным для 16 SCK + запас.
  - TIM3_UP используется как DMA-request на каждый семпл.

**Шаг 3 — Запуск SPI без CPU на 400 кГц**
- TIM3_UP → DMA(M2P) → запись одного 16-бит dummy слова в `SPI1->TXDR` (каждый семпл).
- SPI1:
  - генерирует 16 импульсов SCK и принимает одно 16-бит слово (`SDO_A`) в RX FIFO → DMA(P2M).
- SPI2:
  - slave, принимает одно 16-бит слово (`SDO_B`) синхронно со SPI1 → DMA(P2M).

Примечание: порядок старта DMA критичен (см. ADR-006): SPI2_RX DMA должна быть взведена до первого кадра, иначе возможна потеря старших бит/слов.

### 4.4) DMA/буферы и вычисление “средних по периоду”
**Данные**
- На каждом шаге `k` TIM3_UP запускает DMA→SPI1_TX, после чего SPI1/SPI2 RX DMA записывают по одному слову в SRAM.
- В SRAM хранится массив из `N` пар (`A[k]`, `B[k]`) на полный PWM-цикл + метаданные (`fast_seq`, `t0_us`). Отображение `A/B` на логические `I_weld/U_weld` фиксируется отдельно (bring-up/калибровка).

**Расчёт средних (в конце периода, TIM1 Update/UEV)**
После отображения `A/B` на `I/U`:
```text
I_per = mean(I[0..N-1])
U_per = mean(U[0..N-1])
P_per = mean(I[k] * U[k])
```
Примечание: вычисления “средних” выполняются в том домене/контексте, где это укладывается в бюджет времени (в fast — только если доказано измерениями; иначе — в slow с переносом массива/агрегатов).

### 4.5) Scope (pre/post окна) поверх этой схемы
- Для Scope блоки данных естественно формировать “пакетами” по нескольким PWM-периодам: `block_periods` периодов ⇒ `block_samples = block_periods * N` выборок на канал.
- Pre-trigger: кольцо последних `pre_ms` в SRAM (в блоках).
- Post-trigger: дозапись `post_ms`, затем READY/UPLOAD.

### 4.6) Что обязательно уточнить при переходе к реализации
- Достаточно ли окна `CS` (TIM3 CH2) для 16 SCK при выбранной частоте SPI1 + запас (и подтверждение осциллографом).
- Корректный источник DMA-request: именно `TIM3_UP` (а не `TIM3_CH2`), иначе SCK может “вылезти” за границы CS.
- Как обновляется `N`/`Δt` при смене `f_pwm` (если PWM частота изменяемая в диапазоне 1–4 кГц).
- Точный формат “1 sample” в DMA (2×u16 vs u32) и порядок каналов.
- Лимит прерываний DMA (half/full) и измеренный вклад в джиттер fast домена (если ISR используется для событий блока).
- Нужна ли обработка “первого кадра после enable” как потенциально некорректного (подтвердить экспериментально при bring-up).

## 5) Proof / Measurements (минимум)
- On-target:
  - подтвердить, что чтение `timestamp_us` и запись метаданных блока DMA укладываются в O(1) и не увеличивают джиттер fast loop;
  - подтвердить, что `fast_seq` соответствует 1 инкременту на полный PWM-цикл (с учётом center-aligned + `RCR=1`);
  - подтвердить, что запуск/окна AD7380 совпадают со схемой (GPIO метки + осциллограф).

## 6) Open questions
- Какой именно таймер выбран под `timestamp_us`, а какой под `fast_seq` (TIM2 vs TIM5) с учётом занятости периферии?
- Нужна ли фазовая привязка `pwm_phase_ticks` для целей анализа, или достаточно (`fast_seq`, `timestamp_us`)?
- Требуется ли фиксировать в Trace/Scope “индекс семпла внутри периода” (`k=0..N-1`) как отдельное поле для удобства корреляции на ПК?
- Нужно ли останавливать/замораживать сбор выборок AD7380 при fault (BKIN/DRV_EN) или корректнее “best-effort” до конца текущего периода (политика/доказательства)?
