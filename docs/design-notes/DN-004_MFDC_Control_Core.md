# DN-004 — `control_core` (ядро управления: fast/slow API, PI+ограничители)

Статус: draft  
Дата: 2026-02-10  
Владелец: TBD  
Связано: `docs/PROJECT_CONTEXT.md` (тайминги/PWM, измерения, safety), `docs/ARCHITECTURE.md` (границы модулей), `docs/TEST_PLAN.md` (L1/L2/L3), `docs/ENGINEERING_CONTRACT.md` (defensive design, fast/slow sync, proof), `docs/verification/MFDC_Master_Document_RU.md` (API ядра), `docs/design-notes/DN-001_MFDC_Current_Control.md` (нормативные требования к контуру)  

---

## 1) Context / Problem
Требуется реализовать модуль `control_core` как **платформо-независимое** ядро управления сварочным током (MFDC), пригодное для host unit tests и дальнейшего SIL.  
Все требования по defensive design, синхронизации fast/slow и доказательствам применяются в соответствии с `docs/ENGINEERING_CONTRACT.md`.  
Система имеет два временных домена (см. `docs/PROJECT_CONTEXT.md` и `docs/ARCHITECTURE.md`):
- быстрый домен: шаг управления **1 раз на период PWM** (TIM1, 1–4 кГц), детерминированно, без RTOS;
- медленный домен: обработка команд/параметров с периодом **1 мс** (EtherCAT PDO) и сервисные функции в FreeRTOS.

Поскольку домен управления относится к safety-critical (влияет на формирование тока и взаимодействует с разрешением сварки/безопасным состоянием), требуется заранее зафиксировать:
- границы ответственности `control_core` (что делает / что НЕ делает),
- интерфейсы входов/выходов (в терминах “core”, без HAL),
- требования к детерминизму/таймингам,
- минимальные доказательства корректности (host unit tests как базовая регрессия).

## 2) Goal / Non-goals
### Goal
- Реализовать `control_core` как чистую C-логику без зависимостей от HAL/CMSIS/FreeRTOS (см. `docs/ARCHITECTURE.md` / принципы P1).
- Обеспечить API ядра управления вида `control_init()`, `control_fast_step()`, `control_slow_step()` (см. `docs/verification/MFDC_Master_Document_RU.md`).
- В `control_fast_step()` вычислять управляющее воздействие на основе:
  - уставки тока от ТК (`I_ref_cmd`),
  - усреднённого по периоду PWM измерения тока (и опционально напряжения) из `measurement_core`,
  - разрешения управления (“разрешено варить”) от `safety_supervisor`.
- Реализовать PI-регулятор с ограничением управляющего воздействия и anti-windup, а также conditioning уставки (clamp + slew-rate) в соответствии с DN-001 (`docs/design-notes/DN-001_MFDC_Current_Control.md`) и архитектурой.
- Выдавать наружу не только `u` (управление), но и диагностические флаги/признаки ограничений, чтобы верхний уровень (ТК/логика/диагностика) не “слеп” к насыщениям/лимитам.

### Non-goals
- Не реализовывать `pwm_hal` / TIM1 настройку / BKIN / MOE; `control_core` не имеет права писать регистры (см. `docs/ARCHITECTURE.md` / границы).
- Не реализовывать `measurement_core` и его диагностики (stuck/sat/timeout); `control_core` только потребляет “физику + качество”.
- Не определять политику latch/recovery и классы fault; это ответственность `safety_supervisor`/`state_machine` (см. `docs/ARCHITECTURE.md` / границы).
- Не вводить tuning/автоподстройку/изменение профиля уставки “ради улучшения процесса” (ответственность ТК, см. DN-001).
- Не доказывать тайминги на железе в рамках этой заметки (но зафиксировать обязательность таких доказательств перед включением в силовую часть).

## 3) Decision (что делаем)
- Вводим модуль `control_core` (Core-слой), предоставляющий:
  - `control_init(cfg)` — инициализация параметров и состояния;
  - `control_slow_step(cmd)` — обновление входных команд/параметров из 1 мс домена (без тяжёлой работы);
  - `control_fast_step(in, meas, allow, out)` — детерминированный шаг управления в PWM-домене.

- Алгоритм управления в `control_fast_step()`:
  1) Применить conditioning уставки:
     - clamp `I_ref_cmd` в допустимый диапазон (`I_ref_min..I_ref_max`, значения задаются конфигурацией),
     - slew-rate limiter (ограничение `dI/dt`) с дискретизацией PWM-домена, формируя `I_ref_used`.
  2) Если `allow=false` (запрет сварки) или качество измерений `meas_valid=false`:
     - сформировать `out.enable_request=false` и `out.u=0`,
     - сбросить/заморозить интегратор по политике “безопасный ноль” (по умолчанию: сброс),
     - выставить диагностические флаги (`CTRL_DISABLED`, `MEAS_INVALID`).
  3) Иначе (разрешено и измерения валидны):
     - PI по ошибке `e = I_ref_used - I_meas`,
     - ограничение выхода `u` в диапазоне `u_min..u_max` (нормализованное управление, которое далее маппится в `pwm_hal`),
     - anti-windup (минимум: conditional integration или back-calculation), чтобы интегратор не “убегал” при насыщении,
       - выставление флагов `LIMIT_HI/LIMIT_LO/SAT` и публикация `I_ref_used` наружу.

Примечание (anti-windup, смысл и мотивация):
- При насыщении `u` (в `u_min/u_max`) дальнейшее “ухудшающее” интегрирование не меняет реальное управление (оно зажато лимитом),
  но может накапливать интегратор (windup).
- Windup приводит к затянутому выходу из насыщения и/или перерегулированию после снятия ограничения.
- Поэтому anti-windup SHALL:
  - блокировать интегрирование, если ошибка `e` направлена “в сторону ухудшения насыщения”,
  - ограничивать интегратор (clamp), чтобы исключить уход состояния в экстремальные значения и ускорить восстановление.

- Входы `control_core` (логические, без привязки к железу):
  - команда от ТК: `I_ref_cmd` (и `enable_cmd`, если используется),
  - измерения: усреднённый по периоду PWM `I_meas_per`, опционально `U_meas_per` и/или `Udc` (если подаются в ядро),
  - признаки качества измерений: `meas_valid` (агрегированный признак от `measurement_core`),
  - разрешение сварки: `allow` от `safety_supervisor` (“разрешено вычислять и применять управление”).

- Выходы `control_core` (логические):
  - `u` (нормализованное управляющее воздействие, диапазон задаётся конфигом),
  - `enable_request` (запрос на применение управления, но не “рубильник”),
  - диагностические флаги/счётчики для верхнего уровня:
    - saturation/limit flags,
    - `I_ref_used`,
    - `tracking_bad`/`windup_suspected` (если вводится),
    - счётчики “сколько шагов подряд в ограничении” (для будущей эскалации в `safety_supervisor`).

- Требования к реализации (для совместимости с host tests/SIL и RT-доменом):
  - без динамической памяти;
  - `control_fast_step()` должен быть O(1), без блокировок и без вызовов логирования/printf;
  - зависимость от времени вводится явно: `dt` (либо как параметр fast step, либо как часть конфигурации, обновляемая при смене PWM частоты);
  - `control_core` не принимает решений про fault/recovery (см. `docs/ARCHITECTURE.md` / границы).

## 4) Rationale (почему так)
- Разделение “core vs HAL” следует архитектуре (см. `docs/ARCHITECTURE.md` / P1) и прямо поддерживает L1/L2 (host unit tests и SIL) из `docs/TEST_PLAN.md`.
- API fast/slow фиксирует разнесение доменов (PWM vs 1 мс), снижая риск случайных зависимостей контура от CAN/RTOS (см. `docs/PROJECT_CONTEXT.md`, `docs/ARCHITECTURE.md` / P3).
- PI + ограничения + anti-windup — минимально необходимый набор для управляемого и интерпретируемого поведения в насыщении; DN-001 требует не “прятать” лимиты от ТК и не допускать неконтролируемого роста интегратора.
- “Не варим вслепую”: при `meas_valid=false` ядро обязано запросить `u=0` и сигнализировать проблему; дальнейшая политика (fault/latch) остаётся в `safety_supervisor`.

## 5) Interfaces / Data / Timing impact
- Предполагаемые публичные типы данных `control_core` (имена/точные поля могут уточняться в реализации, но смысл должен сохраняться):
  - `control_cfg_t`: коэффициенты PI, ограничения `u_min/u_max`, пределы `I_ref_*`, `dI_dt_max`, политика anti-windup, `dt`.
  - `control_cmd_t`: команда медленного домена (`I_ref_cmd`, `enable_cmd`, доп. режимы если нужны).
  - `control_meas_t`: значения “физики” (`I_meas_per`, опционально `U_meas_per/Udc`) + `meas_valid`.
  - `control_out_t`: `u`, `enable_request`, `I_ref_used`, флаги ограничений/сатураций/диагностики.

- Timing impact:
  - `control_fast_step()` вызывается раз в период PWM (1–4 кГц, см. `docs/PROJECT_CONTEXT.md` / тайминги).
  - Требование: детерминированная стоимость вычисления; тяжёлые операции (логирование, поиск по таблицам, NVM, протокол) исключены.
  - Бюджет времени и джиттер для полного fast loop измеряются on-target отдельно (см. `docs/TEST_PLAN.md` L3), но `control_core` проектируется так, чтобы не быть доминирующей нагрузкой.

- Обратная совместимость:
  - `control_core` вводится как отдельный модуль; интеграция с `pwm_hal`/`measurement_core` выполняется через адаптеры, без протаскивания HAL в core.

## 6) Risks / Edge cases
- Конкурентный доступ fast/slow: риск “рваных” обновлений уставки/параметров, если общий объект обновляется без атомарности. Митигировать интеграцией (снапшот/sequence counter/critical section) вне `control_core`.
- Неправильная обработка `meas_valid`: если `meas_valid` будет ошибочно true при невалидных измерениях, возможна “варка вслепую”. Требование: `measurement_core` должен быть консервативным; `control_core` — не увеличивать риск (при сомнении → `u=0`).
- Смена PWM частоты (1–4 кГц): если `dt` не обновлён, PI и slew-rate будут некорректны. Требование: `dt` считается частью контракта конфигурации.
- Насыщение и anti-windup: неверная реализация может приводить к длительному “перерегулированию” после выхода из ограничения. Требование: отдельные unit-тесты на насыщение.
- Знак/диапазоны: ток/уставка могут иметь только неотрицательный диапазон или двуполярный (TBD по режимам). Если в проекте ток только ≥0, то отрицательные значения должны быть жёстко отсечены на входе.

### 6.1 Fast/Slow sync (double-buffer + atomic idx)
Цель: гарантировать, что fast-домен читает согласованную команду, даже если slow-домен обновляет структуру команды конкурентно.
Это требование следует `docs/ENGINEERING_CONTRACT.md` / E4.

Рекомендуемый паттерн: двойная буферизация команд с атомарным переключением индекса.

Writer (slow-домен, `control_slow_step()`):
1) выбрать неактивный буфер (`active_idx ^ 1`);
2) записать `cmd` целиком в неактивный буфер;
3) `atomic_store(active_idx, next_idx)` с release-семантикой.

Reader (fast-домен, `control_fast_step()`):
1) `atomic_load(active_idx)` с acquire-семантикой;
2) прочитать `cmd` из активного буфера.

Примечание: reader не читает буфер, который пишет writer, поэтому нет data race и нет провалов из-за прерывания writer'а.

## 7) Test plan / Proof / Rollback
### Test plan / Proof
- Unit/host:
  - PI: ступенька уставки (на синтетической “модели объекта” 1-го порядка), проверка знака, стабильности и отсутствия NaN/переполнений.
  - Ограничение выхода `u_min/u_max`: флаги LIMIT_HI/LO, корректное зажатие.
  - Anti-windup: длительное насыщение → интегратор не “убегает”, после выхода из насыщения нет неконтролируемого выброса.
  - Slew-rate (`dI/dt`): при резкой команде `I_ref_cmd` формируется монотонный `I_ref_used` с заданным пределом изменения на шаг.
  - `allow=false`: выход `u=0`, `enable_request=false`, интегратор в безопасном состоянии (по политике).
  - `meas_valid=false`: выход `u=0`, диагностический флаг выставлен, интегратор безопасно обработан.
  - Регрессия границ: `I_ref_cmd` ниже/выше допустимого → clamp и корректные флаги.
- SIL:
  - (не требуется для принятия этого DN, но архитектурно поддерживается) прогон на трассах команд/измерений по API `control_*` (см. `docs/TEST_PLAN.md` L2).
- On-target измерения (GPIO/осциллограф/trace):
  - (не входит в “Done/Proof” для текущего шага по условиям задачи, но ОБЯЗАТЕЛЬНО перед включением в силовую часть) измерить длительность и джиттер `control_fast_step()` в составе fast loop (см. `docs/TEST_PLAN.md` L3).
- HIL/bench:
  - (следующий этап) проверка “не варим вслепую” и реакций на отказные сценарии по политике `safety_supervisor` (см. `docs/TEST_PLAN.md` L4).

### Rollback
- Быстрый откат: отключить использование `control_core` в интеграции и вернуть предыдущее поведение (например, сервисный `ManualDuty`/PWM OFF) без изменения модулей безопасности (`safety_supervisor`/`pwm_hal` должны оставаться источником safe state).
- Режим безопасного отката при любых сомнениях: `allow=false` ⇒ `u=0`, `enable_request=false` (control_core не должен препятствовать переходу в safe state).

## 8) Status / Implementation links
- Status: draft
- Links: TBD (PR/issue/commit)

