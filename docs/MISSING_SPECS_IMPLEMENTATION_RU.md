# Недостающие спецификации для реализации (Firmware + тесты + сниффинг)

Назначение: зафиксировать **что именно нужно дописать/уточнить**, чтобы прошивка и тесты могли быть реализованы **без догадок**, а протокол — устойчиво анализироваться сниффером.

Область: документация в `docs/` (в первую очередь `PROJECT_CONTEXT.md`, `SAFETY.md`, `PROTOCOL_TK.md`, `TEST_PLAN.md`).
Не цель: переписывать архитектуру или “угадывать” значения TBD.

Легенда приоритета:
- **P0 (blocker)** — без этого нельзя корректно реализовать/совместить узлы.
- **P1 (важно)** — можно начать разработку, но высок риск переделок/ошибок.
- **P2 (улучшение)** — повышает доказуемость/удобство отладки.

---

## 1) Протокол CAN/CAN FD (P0)

### 1.1 Сериализация payload по байтам (P0)

Нужно: для каждого сообщения (`FAULT 0x010`, `CMD_WELD 0x020`, `FB_STATUS 0x030`, `SERVICE_REQ 0x060`, `SERVICE_RESP 0x070`) зафиксировать:
- DLC (и допустимые варианты DLC, если они есть),
- порядок байт для multi-byte (LE/BE),
- битовые поля: позиции/зарезервированные биты MUST=0,
- диапазоны/валидаторы (в т.ч. реакция на out-of-range),
- поведение при несовместимости версии (если будет версионирование).

Ссылки:
- `docs/protocols/PROTOCOL_TK.md:1` (Draft 0.2, единицы тока = mA, `int32_t`).
- `docs/protocols/tk_protocol.dbc` — сейчас скелет, ожидает фиксирования байтовой раскладки.

Шаблон таблицы (заполнить для каждого сообщения):
- CAN-ID: `0x___`, имя: `_____`, DLC: `__`
- Byte offsets:
  - `byte0..1`: `seq` (u16, LE/BE)
  - `byteX..Y`: `I_ref_cmd` (i32, mA, LE/BE)
  - …

### 1.2 Константы/пороги для валидатора (P0)

Нужно зафиксировать значения, которые попадут в код как константы:
- `I_ref_max_mA` (или таблица/режимы, если зависит от конфигурации),
- диапазон `max_slew_rate_mA_ms` (и поведение при 0/отрицательных/слишком больших),
- если `limits` расширяются: что именно входит в кадр и как валидируется.

Ссылки: `docs/protocols/PROTOCOL_TK.md:80`, `docs/protocols/PROTOCOL_TK.md:81`.

### 1.3 `SERVICE_RESP` и `fault_code` (P0/P1)

Нужно:
- точный формат `SERVICE_RESP` (минимум для `ManualDuty`: active, duty_used, age_ms),
- перечень/кодировка `fault_code` (если действительно нужен отдельный enum) и его связь с `fault_word`.

Ссылки: `docs/protocols/PROTOCOL_TK.md:122`, `docs/protocols/PROTOCOL_TK.md:272`.

---

## 2) HW I/O карта (МК ↔ плата) (P0)

Сейчас в `PROJECT_CONTEXT.md` есть список блоков, но нет карты выводов и полярностей. Для прошивки это критично: “safe on reset”, правильные pull-up/down, EXTI, приоритеты IRQ.

### 2.1 Драйверы затворов: EN/INH/FAULT/READY (P0)

Нужно зафиксировать:
- какие сигналы реально разведены,
- их полярность (активный уровень),
- тип выхода (open-collector/push-pull) и требуемые подтяжки,
- на какие GPIO STM32 заведены (порт/пин/AF/EXTI).

Ссылка: `docs/PROJECT_CONTEXT.md:72` (поля пока пустые: `ENABLE/INH/DRV_EN`, `FAULT/READY/STATUS`).

### 2.2 Watchdog CBM706T (P0/P1)

Нужно зафиксировать:
- какой GPIO пинает WDI (если пинает),
- полярности FAULT_OUT/RESET_OUT на плате и что именно они запрещают (DRV_EN/SDI/…),
- требования к “safe on boot” (что должно быть в reset/Hi-Z).

Ссылки: `docs/PROJECT_CONTEXT.md` / раздел 4 и 6, `docs/safety/SAFETY_CONCEPT_CBM706T_RU.md`.

### 2.3 CAN/USB-UART/QSPI/SPI3/SPI4 (P0/P1)

Нужно:
- таблица пинов и AF для: FDCAN1, FT232H UART/USB, QSPI FRAM, SPI3/SPI4 (AD7606), SPI (AD7380),
- назначение CS/DRDY/BUSY/RESET у АЦП (если есть), линии синхронизации/триггеров,
- DMA каналы/приоритеты и IRQ приоритеты (чтобы доказать отсутствие влияния на fast loop).

---

## 3) Измерения и диагностика (P0/P1)

### 3.1 AD7606: каналы и электрические типы датчиков (P0)

Сейчас в `PROJECT_CONTEXT.md` описано “какие сигналы куда”, но для кода нужно:
- диапазоны входов AD7606, масштабирование в единицы (А/В/°C),
- тип датчиков температуры (NTC/RTD/аналоговый датчик) и их характеристики/линейки,
- требования к диагностике: обрыв/КЗ/выход за диапазон для температур.

Ссылка: `docs/PROJECT_CONTEXT.md:37`.

### 3.2 Диагностика “валидности” измерений (P0/P1)

Нужно зафиксировать пороги/окна:
- `N` выборок AD7380 на период PWM и как синхронизируется с PWM (уже отмечено как TBD в theory),
- пороги `stuck/sat`, timeout, окна подтверждения,
- параметры zero-drift/калибровки нуля: `T_zero_guard_ms`, `M` периодов, пороги дисперсии.

Ссылки:
- `docs/theory/MFDC_Software_Architecture_STM32G474.md:99` (N TBD),
- `docs/theory/MFDC_Current_Loop_and_Fault_Model_STM32G474.md:33` (N TBD),
- `docs/measurements/MEASUREMENT_ARCHITECTURE_RU.md:223` (TBD).

---

## 4) Наблюдаемость и логи (P1/P2)

### 4.1 DBG0/DBG1: контракт событий (P1)

Нужно формально определить:
- перечень событий, которые можно вывести на DBG0/DBG1 (enum),
- где хранится/как передаётся текущая конфигурация (лог/телеметрия/PCcom),
- стандартные конфигурации для тестов (например: `CTRL_TICK` и `PWM_APPLY`).

Ссылки: `docs/PROJECT_CONTEXT.md` / раздел 7, `docs/TEST_PLAN.md` / раздел 4.

### 4.2 Форматы логов CAN (P2)

Рекомендация (уже добавлено):
- `docs/protocols/CAN_LOGGING_HOWTO_RU.md` — правила записи логов для сниффинга,
- `docs/protocols/tk_protocol.dbc` — для декодирования.

---

## 5) Политика recovery и “кто имеет право” (P1)

Нужно убрать неоднозначности:
- точный механизм recovery: только `fault_reset` в `CMD_WELD` или отдельная service-команда, или оба,
- условия, при которых recovery разрешён (таймауты, отсутствие fault, задержки).

Ссылки: `docs/SAFETY.md:111`, `docs/protocols/PROTOCOL_TK.md` / раздел 3.

---

## 6) Рекомендованный план закрытия пробелов (коротко)

1) Зафиксировать таблицы байтовой раскладки в `docs/protocols/PROTOCOL_TK.md` (P0).
2) Создать `docs/HW_IO_MAP.md` (или секцию в `PROJECT_CONTEXT.md`) с GPIO/полярностями/подтяжками/AF/IRQ (P0).
3) Закрыть TBD по измерениям (N, окна, пороги) и описать диагностику температур/AD7606 (P0/P1).
4) Определить enum событий DBG0/DBG1 и привязать к тестам (P1).

