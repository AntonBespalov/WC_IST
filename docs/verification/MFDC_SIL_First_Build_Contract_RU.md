# MFDC: SIL-first build contract (host L1/L2) + интеграция в Jenkins

Назначение: зафиксировать **контракт сборки и запуска host-тестов (L1 unit + L2 SIL)** так, чтобы:
- SIL/юнит-тесты можно было гонять в Jenkins на Linux-агентах воспроизводимо и быстро;
- появление/эволюция прошивочного (STM32CubeIDE) проекта не ломали host-контур;
- артефакты доказательств (логи/трассы/отчёты) были одинаковыми для CI и локального прогона.

Ссылки на “источники правды”:
- требования по тестируемости и границам Core/HAL: `docs/ARCHITECTURE.md` (см. разделы 2.1, 4.1, 4.2);
- уровни тестирования L1/L2 и артефакты: `docs/TEST_PLAN.md` (см. разделы L1, L2, “Артефакты тестирования”);
- обязательный API ядра управления и SIL-сценарии: `docs/verification/MFDC_Master_Document_RU.md` (см. раздел 5).

---

## 1) Область действия и цели

Этот контракт описывает **только host-контур**:
- **L1 (host unit tests)** — проверка core-логики без HAL/RTOS.
- **L2 (SIL)** — прогон управления на трассах (golden traces / синтетика / record-replay).

Не входит в этот контракт:
- сборка прошивки (target) и её toolchain/IDE (это отдельный контур; в Jenkins сейчас используется STM32CubeIDE headlessbuild);
- HIL/on-target/bench (но артефактная дисциплина здесь должна быть совместима с ними).

---

## 2) Инварианты (что нельзя нарушать)

I1) **Core компилируется на host без HAL/CMSIS/FreeRTOS.**  
Это ключевое архитектурное требование для SIL и быстрых регрессий.

I2) **У ядра управления минимальный API** (см. `MFDC_Master_Document_RU.md` / раздел 5.2):
- `control_init()`
- `control_fast_step()`
- `control_slow_step()`

I3) **SIL является data-driven:** вход — трасса “измерения + команды/события”, выход — “duty/state/fault_flags + метрики”, сравнение с эталоном выполняется автоматом в CI.

I4) **SIL не заменяет HIL/on-target** (см. `docs/verification/MFDC_Red_Team_Review_RU.md` / “Слепые зоны SIL”): SIL даёт воспроизводимость/регрессию алгоритмов, но не доказывает реальные тайминги и аппаратные пути отключения.

---

## 3) Организация репозитория (ожидаемая структура)

Когда появится код, он должен разложиться так, чтобы граница Core/HAL была тестопригодной (см. `docs/ARCHITECTURE.md` / раздел 2):

- `src/core/` — платформо-независимая логика (control/measurement/safety/protocol/state machine).
- `src/platform/` — HAL/RTOS/драйверы (на host не собирается).
- `tests/unit/` — L1 unit tests.
- `tests/sil/` — L2 SIL runner + проверки/метрики.
- `tests/traces/` — **golden traces** (входы) + эталоны/допуски (ожидаемые выходы/метрики).
- `ci/` — CI-шаблоны (Jenkinsfile и др.).

Примечание: конкретные имена каталогов могут отличаться, но:
- `tests/traces/` рекомендуется сохранить как “каноническое место” (см. `docs/ARCHITECTURE.md` / 4.2);
- `src/core/` должен быть физически отделён от `src/platform/`, чтобы исключить “случайные” include/HAL-зависимости.

---

## 4) Система сборки host-контуров

Выбор: **CMake + CTest**.

Требования к окружению CI (Linux агент):
- `cmake` (рекомендуется версия, поддерживающая `ctest --output-junit`, чтобы стабильно получать JUnit XML);
- один из компиляторов: `gcc` или `clang`;
- `ninja` опционально (ускоряет сборку, но не обязателен).

### 4.1 Минимальные цели сборки (CMake targets)

Host CMake должен собирать (как минимум):
- `core` (library) — код из `src/core/`.
- `unit_tests` (executable или набор executable) — L1.
- `sil_runner` — L2, читает трассы и выдаёт PASS/FAIL по допускам/метрикам.

Важно: host-цели **не должны** зависеть от `src/platform/` и от STM32 toolchain.

### 4.2 CTest: лейблы и профили прогона

Каждому тесту назначается `LABELS`, чтобы Jenkins мог выбирать наборы:
- `L1` — host unit tests.
- `L2_smoke` — короткий L2 (несколько трасс, быстро) для PR.
- `L2` — полный L2 прогон (все трассы) для nightly/release.

Рекомендация по политике CI:
- PR: `L1` + `L2_smoke`.
- Nightly/release: `L1` + `L2`.

---

## 5) Контракт трасс (golden traces)

Цель трасс — воспроизводимость и регрессия (см. `docs/TEST_PLAN.md` / L2).

Контракт минимально необходимого содержания одной трассы:
- “время” (ticks/мкс или индекс шага);
- входы измерений (raw или физика — по выбранному уровню моделирования);
- входы команд (например, команда/уставка/режим + seq/time);
- события fault-инъекции (например, “stuck/sat/timeout/комм-таймаут”).

Выход SIL должен включать:
- ключевые выходы управления (например, `duty`/enable-request);
- `state`/`fault_flags` (или эквивалент);
- метрики из V&V (см. `docs/verification/MFDC_Verification_Plan_RU.md` / SIL-метрики): перерегулирование, время установления, устойчивость, отсутствие NaN/overflow.

Практическое правило: трасса и эталон должны быть **версионированы** (см. требования к трассируемости в DN-001 и общий принцип “Hazard → Test case → Evidence”).

---

## 6) Артефакты (что сохраняем в Jenkins)

Минимальный набор артефактов для каждого прогона host L1/L2:
- JUnit XML отчёт(ы) CTest (для истории/диффов/гейтинга);
- `tests/traces/` (как минимум набор, который был прогнан; если он большой — сохранять список/манифест);
- `sil_summary.*` (короткое резюме: git sha, режим прогона, список трасс, итоговые метрики/провалы).

Это напрямую соответствует требованию `docs/TEST_PLAN.md` / “Артефакты тестирования”.

---

## 7) Интеграция в Jenkins

Факт текущего CI (по примеру аналогичного проекта):
- Linux агент;
- target собирается через STM32CubeIDE headlessbuild;
- это **не мешает** добавить второй контур host L1/L2 на CMake+CTest.

### 7.1 Предпочтительный путь (через shared library)

Если используется shared library (как в примере `pipelineSTM32Cube { ... }`), добавить в неё:
- опциональные стейджи host L1/L2 (CMake configure/build + CTest);
- публикацию JUnit и архивирование артефактов.

Параметры, которые стоит предусмотреть в library-шаге:
- `with_host_tests` (bool)
- `host_cmake_source_dir` (путь к host CMakeLists)
- `host_ctest_labels` (например, `L1;L2_smoke` / `L1;L2`)
- `host_build_dir` (например, `build/host`)

### 7.2 Резервный путь (отдельный Jenkinsfile)

Если модифицировать shared library нельзя, заводится отдельный job с Jenkinsfile,
который делает checkout и гоняет только host L1/L2. Шаблон лежит в `ci/Jenkinsfile.host-sil`.

---

## 8) Критерий “готово” для внедрения SIL-first

Считаем внедрение “SIL-first” выполненным, когда:
- в CI есть отдельные результаты для `L1` и `L2_smoke` на каждом PR;
- `L2` прогон доступен для nightly/release;
- артефакты (JUnit + sil_summary + traces/manifest) сохраняются и просматриваются;
- Core реально собирается на host без HAL/RTOS (инвариант I1), и это защищено сборкой.

