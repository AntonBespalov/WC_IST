# Шаблоны запросов к Codex/LLM (под этот проект)

Используй `docs/CONTEXT_SNAPSHOT.md` как короткую вставку контекста.
Если задача safety/тайминги/измерения/обмен — подключай соответствующие skills.

---

## Мини-шапка запроса (MUST) — копипаста в начало любого промпта
Заполни 5 строк. Если не можешь заполнить хотя бы одну — сначала запускай ворота.

- Цель (и что НЕ менять):
- Разрешённые файлы/модули:
- Контекст исполнения (task/ISR/DMA):
- Временной домен (PWM / 1 мс / async fault / другое):
- Done/Proof (как проверяем и что доказываем):

Если любая строка пустая или “TBD”:
→ сначала используй skill `ask-questions-embedded-stm32-freertos` и ответь в формате `defaults` или `0a 1b ...`.

---

## Шаблон 0 — “Ленивая работа с контекстом” (вставка в любой запрос)
Когда применять:
- Всегда, как пролог к любому запросу в этом репозитории (чтобы модель не “домысливала” факты).
- Когда есть риск разъезда терминов/политик: вместо цитирования — ссылки на `docs/*` и конкретные разделы.
- Когда контекста недостаточно: попросить вопросы/допущения, а не “ответ наугад”.

> Используй `docs/PROJECT_CONTEXT.md` и `docs/GLOSSARY.md` как источники правды.  
> Работай “лениво”: **не перепечатывай** документы целиком; ссылайся на секции/названия.  
> Если информации не хватает — перечисли минимальные вопросы или явные допущения.

> Если mini-шапка MUST не заполнена (есть пустые/TBD) — сначала запусти `ask-questions-embedded-stm32-freertos`, затем возвращайся к шаблону.


---

## Шаблон 1 — Spec → DN → Tests/Proof → Code (надёжный режим)
Когда применять:
- Новая фича или изменение поведения (особенно если затрагивает контуры времени: PWM/1 мс/async fault).
- Любые изменения в safety/таймингах/измерениях/обмене, когда нужно “сначала доказательства, потом код”.
- Когда по итогам обсуждения нужно получить артефакт для репозитория: DN draft + план тестов/измерений.

**Skills:** `workflow-spec-tests-code`, `test-verification-welding-short`, (если код) `patch-discipline-small-diffs`, (если safety) `safety-invariants-welding`

> Используй skills: `workflow-spec-tests-code` и `test-verification-welding-short`.  
> Контекст (кратко): [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Задача: <что хотим изменить>.  
> Ограничения: <что нельзя менять / какие файлы трогать можно>.  
> Выход:  
> 1) Spec (требования, критерии приёмки, инварианты),  
> 2) DN draft (выжимка “что/как/почему + test plan/rollback” для `docs/design-notes/`),  
> 3) Tests/Proof (unit/on-target/HIL/fault-injection + что мерить осциллографом),  
> 4) Code plan (файлы + план коммитов).  
> Код НЕ пиши, пока я не попрошу.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.



---

## Шаблон 1a — ADR (архитектурное решение) в репозиторий
Когда применять:
- Есть 2+ правдоподобных варианта (A/B/…), и нужен осознанный выбор по критериям.
- Выбор влияет на интерфейсы/тайминги/safety/протокол или заметно меняет объём доказательств (tests/proof).
- Нужно “зафиксировать почему выбрали так”, чтобы через месяц это можно было ревьюить/пересмотреть.

**Skills:** `system-design-interrogation` (если требования ещё не ясны), `adr-writer`

> Используй skill: `adr-writer`.  
> Контекст (кратко): [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Тема ADR: <1 строка>.  
> Ограничения/инварианты: <что нельзя сломать>.  
> Варианты: <A/B (и опционально C)> (если вариантов нет — предложи минимум 2).  
> Done/Proof: <какие evidence/тесты/измерения нужны, чтобы принять решение>.  
> Выход:  
> - предложи имя файла `docs/decisions/ADR-YYYYMMDD-<slug>.md`,  
> - полный текст ADR строго по `docs/decisions/ADR-TEMPLATE.md`.  
> Код НЕ пиши.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 1b — Принятый ADR → DN → план реализации (без кода)
Когда применять:
- ADR уже принят (вариант выбран), и нужно “приземлить” решение в конкретные изменения модулей/интерфейсов/таймингов и доказательства.
- Требуется превратить “архитектурный выбор” в реализационный контракт (DN) перед кодом/PR.
- Изменение затрагивает архитектуру/границы модулей/обмен/тайминги/safety и без DN легко сделать неверный патч.

**Skills:** `workflow-spec-tests-code`, `dn-writer`, `test-verification-welding-short`, (если затем будет код) `patch-discipline-small-diffs`, (если затрагивает safety) `safety-invariants-welding`

> Используй skills: `workflow-spec-tests-code`, `dn-writer` и `test-verification-welding-short`.  
> Контекст (кратко): [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> ADR (принят): `docs/decisions/<ADR-file>.md` (укажи секции/пункты Decision/Interfaces/Timing impact, которые реализуем).  
> Задача: реализовать принятое архитектурное решение из ADR.  
> Ограничения: <что нельзя менять / какие файлы трогать можно>.  
> Выход:  
> 1) Кратко: что именно требует ADR (1–2 абзаца, без пересказа всего документа),  
> 2) DN draft строго по `docs/design-notes/DN-TEMPLATE.md` (с явными Goal/Non-goals, Interfaces/Timing impact, Risks, Test plan/Proof/Rollback),  
> 3) Tests/Proof: unit/on-target/HIL + что мерить (GPIO/осциллограф/trace) + fault-injection сценарии,  
> 4) Code plan: список файлов + план коммитов + критерии приёмки.  
> Код НЕ пиши, пока я не попрошу (после утверждения DN перейдём на Шаблон 2).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 1c — DN (Design Note) в репозиторий по итогам обсуждения
Когда применять:
- Требования/решение уже понятны, но их нужно зафиксировать в репозитории перед реализацией/ревью.
- Нужно оформить Goal/Non-goals, инварианты, влияние на тайминги/интерфейсы и обязательный Test plan / Proof / Rollback.
- После обсуждения в чате, когда есть риск “потерять Spec” без DN.

**Skills:** `dn-writer` (+ `test-verification-welding-short` если нужно усилить proof obligations)

> Используй skill: `dn-writer`.  
> Контекст (кратко): [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Задача: <что хотим изменить>.  
> Ограничения: <что нельзя менять / какие файлы трогать можно>.  
> Done/Proof: <как проверяем и что доказываем>.  
> Выход:  
> - предложи имя файла `docs/design-notes/DN-XXX_<short_name>.md`,  
> - полный текст DN строго по `docs/design-notes/DN-TEMPLATE.md`.  
> Код НЕ пиши.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 2 — Реализация минимальным патчем
Когда применять:
- Требования/критерии “готово” уже заданы (или есть DN/ADR), и нужна реализация в коде.
- Нужно ограничить дифф и избежать “скрытых” рефакторингов/форматирования.
- Важно не забыть proof obligations: что измерить на железе, какие fault-injection сценарии прогнать.

**Skills:** `patch-discipline-small-diffs`, `test-verification-welding-short` (+ `safety-invariants-welding` при необходимости)

> Используй skills: `patch-discipline-small-diffs` и `test-verification-welding-short`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Реализуй: <конкретная фича/фикс>.  
> Разрешённые файлы: <список>.  
> Запрещено: рефакторинг/переименования/форматирование вне нужного.  
> Стандарт кода: соблюдать `docs/CODING_STANDARD_RU.md` (комментарии на русском, UTF-8/CRLF; для safety/RT мест — краткий блок `// SAFETY:` с инвариантами/причинами решений).  
> STM32CubeIDE: если добавляешь новую папку с кодом — обнови include paths и `sourceEntries` в `.cproject` (см. `docs/HOW_TO_USE_RU.md` / раздел 5).  
> Выход:  
> - кратко: какие файлы изменил и почему,  
> - патч/код,  
> - какие тесты добавить/обновить + критерии приёмки (и что измерить на железе, если актуально).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 3 — Red-team review готового PR/патча
Когда применять:
- После реализации (или на ревью PR), особенно для критичных модулей control/measurement/safety/comms.
- Когда изменения могут повлиять на тайминги, shutdown-path, разрешение сварки, валидность измерений или 1 мс обмен.
- Когда нужна проверка “что может сломаться в реальности” и требования к доказательствам (измерения/fault-injection).

**Skills:** `red-team-review-welding` (+ `safety-invariants-welding`)

> Используй skill: `red-team-review-welding`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Вот дифф/PR: <вставь изменения>.  
> Задача: найти проблемы (тайминги/гонки/отказы/нарушение safety-инвариантов).  
> Выход:  
> - 10+ рисков: симптом, причина, как воспроизвести (fault-injection/тест), как доказать (GPIO/лог), минимальная правка.  
> - отдельным списком: что обязательно измерить на железе (BKIN_RAW→PWM_OUT, jitter, ADC latency и т.п.).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 4 — План HIL для конкретного модуля/фичи
Когда применять:
- Есть риск включать силовую часть рано: нужен HIL до power bench.
- Требуется спланировать эмуляцию измерений/сигналов и fault-injection сценарии без киловатт.
- Нужно заранее определить, что именно мерить (GPIO/осциллограф/trace) и какие критерии PASS/FAIL.

**Skills:** `test-verification-welding-short` (+ `workflow-spec-tests-code`)

> Используй skill: `test-verification-welding-short`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Нужен план HIL для: <что тестируем>.  
> Дай:  
> - какие сигналы эмулировать (ток/напряжение/ошибки),  
> - сценарии (норма, плохой контакт, перегрузка, stuck/sat/timeout),  
> - критерии приёмки,  
> - какие линии аварий дёргать (BKIN/DRV_EN),  
> - что логировать (record/replay).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 5 — Протокол ТК (дизайн/изменение)
Когда применять:
- Нужно определить/изменить CAN-протокол обмена с ТК: поля, таймауты, seq/CRC, коды ошибок, совместимость.
- Требуется закрыть P0/P1 пункты из `docs/MISSING_SPECS_IMPLEMENTATION_RU.md` по сериализации/валидаторам.
- Любые изменения, которые должны синхронно отразиться в `PROTOCOL_TK.md` и в DBC для сниффинга.

**Skills:** `workflow-spec-tests-code`, `patch-discipline-small-diffs` (если кодогенерация)

> Используй `docs/protocols/PROTOCOL_TK.md` как источник правды (или заполни шаблон, если файла ещё нет).  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Задача: <определить/изменить поля/таймауты/коды ошибок>.  
> Если в рамках задачи нужен патч/код (кодогенерация/валидаторы/сериализация): соблюдать `docs/CODING_STANDARD_RU.md` (комментарии на русском, UTF-8/CRLF; для safety/RT мест — блок `// SAFETY:` с инвариантами/причинами решений).  
> STM32CubeIDE: если патч добавляет новую папку с кодом — обнови include paths и `sourceEntries` в `.cproject` (см. `docs/HOW_TO_USE_RU.md` / раздел 5).  
> Выход:  
> - изменения в `docs/protocols/PROTOCOL_TK.md` (в виде предложенного текста),  
> - (если меняется раскладка полей) обновление `docs/protocols/tk_protocol.dbc` для сниффинга,  
> - список тестов протокола (timeout/seq/crc/bus-off),  
> - совместимость с текущей реализацией (что сломается).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 6 — Жесткий Аудит / Safety Gate
Когда применять:
- Перед стендом/силовой частью или когда нужен однозначный вердикт “можно/нельзя” (PASS/FAIL).
- Если патч/решение затрагивает shutdown-path (BKIN/DRV_EN), watchdog, latch/recovery, тайминги, 1 мс обмен, валидность измерений.
- Когда есть сомнения в корректности/безопасности и нужно “нуль толерантности к рискам”.

**Skills**: `strict-audit`, `red-team-review-welding`, `safety-invariants-welding`

> Используй skills: `strict-audit` и `red-team-review-welding`.
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].
> Вводные данные: <код, архитектурное решение или PR>.
> Задача: Провести аудит с нулевой толерантностью к рискам.
> Выход:
> - Статус: [AUDIT PASS] / [AUDIT FAIL]
> - Блокирующие замечания (No-Go).
> - Требования к исправлению.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 7 — Научная отладка (symptom → hypothesis → instrumentation → fix)
Когда применять:
- Есть симптом/баг (HardFault, WDG reset, ADC timeout, ложный fault, джиттер, редкие зависания) и нельзя делать “слепые фиксы”.
- Нужно изолировать причину (SW vs timing/RTOS vs HW/EMI) через инструментирование (GPIO/trace/counters/logs).
- Когда требуется воспроизводимый эксперимент и доказательства перед изменением логики.

**Skills:** `debug-scientific-embedded` (+ `test-verification-welding-short` если затрагивает safety/тайминги)

> Используй skill: `debug-scientific-embedded`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Симптом: <что именно не так>.  
> Условия воспроизведения: <когда/как воспроизводится>.  
> Логи/дампы/осциллограммы: <что уже есть>.  
> Выход:  
> - 2–3 гипотезы (SW/RTOS+timing/HW+EMI),  
> - план инструментирования (какие GPIO toggles/счётчики/логи добавить),  
> - минимальный эксперимент для изоляции (HW vs SW),  
> - только потом — минимальный фикс и как проверить.
> Если фикс включает патч/код: соблюдать `docs/CODING_STANDARD_RU.md` (комментарии на русском, UTF-8/CRLF; для safety/RT мест — блок `// SAFETY:` с инвариантами/причинами решений).
> STM32CubeIDE: если патч добавляет новую папку с кодом — обнови include paths и `sourceEntries` в `.cproject` (см. `docs/HOW_TO_USE_RU.md` / раздел 5).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 8 — Complexity/RT аудит (ISR/task, стек, блокировки)
Когда применять:
- Подозрение на overrun/jitter/stack overflow или рост нагрузки в ISR/критичных задачах.
- Перед добавлением “тяжёлой” логики в fast loop / 1 мс домен (парсинг, memcpy, float, логи).
- Когда нужно быстро найти RT-антипаттерны (busy-wait, блокировки, большие копирования) и что измерить на железе.

**Skills:** `complexity-analysis` (+ `red-team-review-welding` при критичных изменениях)

> Используй skill: `complexity-analysis`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Scope: <файлы/функции/ISR/task, которые анализируем>.  
> Временной домен: <PWM / 1 мс / async fault>.  
> Выход:  
> - таблица рисков (ISR “zero fat”, блокировки, busy-wait, float, большие копирования, стек),  
> - worst-case оценка/гипотезы по времени выполнения,  
> - что именно измерить на железе (DBG0/DBG1 + BKIN_RAW/PWM_OUT),  
> - минимальные правки для снижения риска.
> Если “минимальные правки” включают патч/код: соблюдать `docs/CODING_STANDARD_RU.md` (комментарии на русском, UTF-8/CRLF; для safety/RT мест — блок `// SAFETY:` с инвариантами/причинами решений).
> STM32CubeIDE: если патч добавляет новую папку с кодом — обнови include paths и `sourceEntries` в `.cproject` (см. `docs/HOW_TO_USE_RU.md` / раздел 5).

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 9 — Обновить документацию после изменения (Doc sync)
Когда применять:
- После реализации фичи/фикса, если изменились тайминги/интерфейсы/пины/аварии/протокол/архитектура.
- Когда в PR менялся safety/driver/pwm/adc/comms код и нужно синхронизировать “карту” (`docs/*`) с “территорией” (кодом).
- Когда есть риск оставить несогласованные значения/пороги/форматы в документах (особенно вокруг TBD).

**Skills:** `docs-maintainer` (+ `patch-discipline-small-diffs` если вносишь правки)

> Используй skill: `docs-maintainer`.  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Вот изменения/дифф: <вставь diff или перечисли файлы и что изменилось>.  
> Выход:  
> - список `docs/*`, которые нужно обновить (PROJECT_CONTEXT/SAFETY/PROTOCOL/TEST_PLAN/ARCHITECTURE/GLOSSARY),  
> - предложенный текст правок (кусками),  
> - что проверить из `docs/TEST_PLAN.md` как минимальную регрессию.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.

---

## Шаблон 10 — Протокол PCcom4 (плата ↔ ПК): проектные узлы/операции
Когда применять:
- Нужно добавить/изменить сервисные команды плата↔ПК (PCcom4): self-test, осциллограф, настройки, CAN-tunnel, политики service mode.
- Требуется определить формат данных, валидаторы, поведение при бурстах/ресинхронизации/CRC/ошибках длины.
- Когда важно заранее зафиксировать совместимость host↔device (версия/`proto_ver`, обратная совместимость).

**Skills:** `workflow-spec-tests-code` (+ `patch-discipline-small-diffs` если код)

> Источники правды: `docs/protocols/PCCOM4.02.md` (база) и `docs/protocols/PCCOM4.02_PROJECT.md` (профиль проекта).  
> Контекст: [вставь `docs/CONTEXT_SNAPSHOT.md`].  
> Задача: <добавить/изменить узел/операцию/формат данных/политику (service mode, self-test, scope, CAN-tunnel, …)>.  
> Если в рамках задачи нужен патч/код (device/host): соблюдать `docs/CODING_STANDARD_RU.md` (комментарии на русском, UTF-8/CRLF; для safety/RT мест — блок `// SAFETY:` с инвариантами/причинами решений).  
> STM32CubeIDE: если патч добавляет новую папку с кодом — обнови include paths и `sourceEntries` в `.cproject` (см. `docs/HOW_TO_USE_RU.md` / раздел 5).  
> Выход:  
> - предложенные изменения текста в `docs/protocols/PCCOM4.02_PROJECT.md`,  
> - совместимость (как распознаём версию/поле proto_ver; что сломается у старого host),  
> - тесты протокола (CRC/length/resync/burst/backpressure) + что логировать.

> Mini-шапка MUST заполнена выше; если нет — сначала `ask-questions-embedded-stm32-freertos`.
