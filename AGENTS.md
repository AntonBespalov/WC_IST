# AGENTS.md — правила работы Codex/LLM в этом репозитории

Этот файл задаёт соглашения, которые должны соблюдаться при генерации кода/архитектуры/ревью с помощью Codex/LLM.
Цель: воспроизводимость, минимальный риск, проверяемость (tests/proof) и безопасность (safe state).

---

## 1) Источники правды (приоритет)
При противоречиях следовать этому порядку:

1) `docs/PROJECT_CONTEXT.md` — железо, тайминги, интерфейсы, политика safe state (Ground Truth)
2) `docs/GLOSSARY.md` — термины и определения
3) `docs/ARCHITECTURE.md` — модульные границы, тестируемость (host/SIL/HIL/on-target)
4) `docs/SAFETY.md` — расширенная политика аварий/восстановления (если есть)
5) `docs/protocols/PROTOCOL_TK.md` — протокол обмена с ТК (CAN)
6) `docs/protocols/PCCOM4.02.md` — протокол PCcom4 (плата ↔ ПК по USB-UART)
7) `docs/TEST_PLAN.md` — план тестов/матрица требований (если есть)
8) `docs/PROMPT_TEMPLATES.md` — шаблоны запросов к Codex/LLM
9) `.codex/skills/*` — правила формата ответов и акценты (skills не должны спорить с контекстом)

Каталог полезных доп. документов: `docs/DOCS_INDEX.md`.

Если чего-то не хватает или доки расходятся — предлагай правки `docs/*`, а не “домысливай молча”.

---

## 1.1) Ленивая работа с контекстом (обязательное правило)
Чтобы не раздувать контекст и не терять качество:

- Используй `docs/PROJECT_CONTEXT.md` и `docs/GLOSSARY.md` как источники правды, **но не перепечатывай их** в ответе.
- Ссылайся на документ и секцию/заголовок (“см. PROJECT_CONTEXT.md / раздел 4”), а не копируй текст.
- Если информации не хватает:
  - задай минимальные уточняющие вопросы **или**
  - явно зафиксируй допущения (assumptions) и продолжай.
- Не подтягивай “всё подряд” из `docs/` — используй только то, что нужно для текущей задачи.
- Для запросов к Codex по умолчанию вставляй `docs/CONTEXT_SNAPSHOT.md` вместо полного контекста.

Запрещено:
- Вставлять в ответ большие куски документов (копипаст из `docs/*`), если этого не просили явно.

---

## 1.2) Gate: формальная проверка полноты задачи (обязательное правило)
Чтобы убрать двусмысленность “задача недоописана”, вводится детерминированное правило.

### 1.2.1 MUST-поля запроса (минимум входных данных)
Задача считается **недоописанной**, если НЕ задано (или не следует напрямую из открытых документов/файлов) хотя бы одно из:

M1) **Цель**: что именно меняется + что НЕ должно измениться.  
M2) **Границы изменений**: какие файлы/модули разрешено трогать (или “ничего, кроме …”).  
M3) **Контекст исполнения**: task / ISR / DMA / таймерный callback (что реально участвует).  
M4) **Временной домен**: PWM-контур / 1 мс обмен / асинхронный fault / другое.  
M5) **Критерий “готово” (proof/done)**: как проверяем (unit/SIL/on-target GPIO/trace/HIL/bench) и что должно быть доказано.

Примечание (маркировка на русском): в диалоге допускается использовать `М1–М5` (русская буква `М`) как эквивалент `M1–M5`. Подпункты помечать `М1а)`, `М1б)` …; варианты ответа — `вариант А)`, `вариант Б)` … .

### 1.2.2 Правило поведения (светофор)
Перед тем как предлагать план реализации или писать код:
- Выполни self-check M1..M5 (или М1..М5).
- Если **хотя бы одно** поле отсутствует → **остановиться** и вызвать ворота:
  - применить skill `ask-questions-embedded-stm32-freertos`
  - вывести только вопросы/варианты (формат `defaults`; маркировка вопросов/вариантов — `М1а)`, `М1б)` … / `вариант А)` …)
  - не писать код, пока нет ответов или явных допущений, подтверждённых пользователем.

### 1.2.3 Жёсткие триггеры “критично по умолчанию”
Даже если формально M1..M5 (или М1..М5) частично есть, ворота должны сработать, если задача затрагивает хотя бы одно:
- TIM1/PWM/комплементарные выходы/Dead-time/MOE/Break (BKIN/BKIN2)
- DRV_EN/INH, driver fault, recovery/latch, watchdog
- валидность измерений (stuck/sat/timeout/CRC), SPI/DMA для АЦП
- обмен с ТК (1 мс), seq/CRC/таймаут, bus-off
- state machine (IDLE/ARMED/WELD/FAULT) или “разрешение сварки”
- любые утверждения про тайминги (“успеваем”, “в середине периода”, “раз в период”)

Для таких задач:
- если любое из M1..M5 (или М1..М5) не определено → ворота обязательны.


---

## 2) Skills по умолчанию
### 2.0) Прояснение требований (рекомендуется по умолчанию)
Если задача начинается как “давай обсудим/спроектируем/прикинем архитектуру” **или** есть пробелы в MUST-полях `М1–М5` — сначала использовать skill `system-design-interrogation` (файл: `.codex/skills/system-design-interrogation/SKILL.md`).
Этот режим намеренно “медленный”: один вопрос за раз, приоритет Safety → Physics → Hardware → Software → UI, и **без кода**, пока пользователь явно не утвердит Spec (“Spec утвержден”).
После утверждения Spec переходить к `workflow-spec-tests-code` и/или `test-verification-welding-short` по характеру изменения.

### 2.1) Обязательные skills для критичных изменений
Если изменение затрагивает:
- управление сварочным током (регулятор, ШИМ, тайминги),
- измерения (АЦП, фильтрация, диагностика),
- аварии/безопасность (fault, safe state, watchdog),
- обмен с ТК (1 мс цикл, таймауты, bus-off),
то применять:

- `.codex/skills/test-verification-welding-short/SKILL.md` (name: `test-verification-welding-short`)

Если изменение влияет на аппаратный shutdown/recovery/watchdog/политику аварий:
- дополнительно применять `.codex/skills/safety-invariants-welding/SKILL.md` (name: `safety-invariants-welding`)

Если требуется кодогенерация/патч:
- дополнительно применять `.codex/skills/patch-discipline-small-diffs/SKILL.md` (name: `patch-discipline-small-diffs`)

Если требуется “враждебное” ревью PR/патча:
- применять `.codex/skills/red-team-review-welding/SKILL.md` (name: `red-team-review-welding`)

Если нужно работать по процессу Spec → Tests/Proof → Code:
- применять `.codex/skills/workflow-spec-tests-code/SKILL.md` (name: `workflow-spec-tests-code`)

### 2.2) Когда skills можно не применять
- косметические правки (комментарии, форматирование в одном файле),
- правки, не влияющие на поведение контуров времени, измерения, аварии, протокол.

---

## 3) Правила для изменений, влияющих на безопасность и тайминги
Если изменение влияет на safe state, аварии, тайминги или поведение в real-time:

1) **Сначала Spec**: измеримые требования и критерии приёмки (границы, задержки, поведение при fault).
2) **Всегда Tests/Proof**:
   - host unit (если применимо),
   - on-target измерения (GPIO/осциллограф/trace),
   - fault-injection (минимум 5 сценариев для критичных изменений),
   - HIL (если затрагивает устойчивость к помехам/отказам или поведение контура).
3) **Никогда** не полагаться только на RTOS/обычные ISR для отключения силовой части:
   - критические аварии должны иметь аппаратный путь отключения (TIM1 BKIN/BKIN2 + по возможности DRV_EN/INH).
4) Любое утверждение про тайминги (“в середине периода”, “раз в период”, “успеваем”) — только вместе с планом измерений.
5) Overrun критического цикла должен иметь определённое безопасное поведение (controlled stop или fault по политике).

---

## 4) Оформление PR/изменений (рекомендация)
В описании PR (или commit message) указывать:
- что меняется и зачем
- какие требования/критерии приёмки затронуты
- какие тесты добавлены/обновлены (unit/on-target/HIL/bench)
- как проверены тайминги (если актуально)
- какие fault-injection сценарии прогнаны (если актуально)

Если меняются железо/тайминги/политика аварий — обновить:
- `docs/PROJECT_CONTEXT.md` (обязательно)
- при необходимости `docs/GLOSSARY.md`, `docs/ARCHITECTURE.md`, `docs/SAFETY.md`, `docs/protocols/PROTOCOL_TK.md`, `docs/protocols/PCCOM4.02.md`, `docs/TEST_PLAN.md`

---

## 5) Ограничения и запреты для LLM-генерации
- Не использовать секреты/ключи/пароли в коде и документах.
- Не писать “должно работать” без плана измерений/тестов, если вопрос про real-time, аварии или силовую часть.
- Не делать автоперезапуск после критической аварии без явной политики восстановления.
- Не менять аппаратный shutdown-путь без обновления контекста и тестов.
- Не расширять дифф “просто потому что удобно”: минимальные изменения и явные границы.

---

## 7) Язык комментариев и кодировка (политика проекта)
См. `docs/CODING_STANDARD_RU.md`.
Если генерируешь/правишь код:
- комментарии и docstrings писать на русском (англ. термины допустимы),
- не добавлять “комментарии ради комментариев”: комментировать контракт/инварианты/причины решений, особенно в safety/RT местах,
- для всех функций (включая `static`): обязательно Doxygen минимум `@brief/@param/@retval` (или `@return`),
- для публичных функций: Doxygen обязателен на объявлениях в `.h`, а не только у реализации в `.c`,
- для сложных/safety-значимых функций: добавлять уместные блоки `@details/@pre/@post/@note/@warning`,
- для `struct` и `enum`: комментировать каждое поле/элемент,
- для числовых величин (поля структур, параметры и значимые локальные переменные): явно указывать размерность/единицы (например `[А]`, `[В]`, `[с]`, `[А/с]`, `[шаги]`, `[отн. ед.]`),
- для нетривиальных функций (особенно safety/RT): добавлять “скелет алгоритма” по шагам (`Шаг 1..N`) и разделять этапы вычисления,
- при росте вложенности/когнитивной нагрузки: выносить подалгоритмы в `static` helper-функции с предметными именами,
- соблюдать UTF‑8 и CRLF (ориентир: `.editorconfig`).
- STM32CubeIDE: если добавляешь код в каталог вне текущих source roots — обновить include paths и `sourceEntries` в `.cproject` и проверить это в Project Properties (см. `docs/HOW_TO_USE_RU.md` / раздел 5), иначе ломается индексация/переход к объявлению.

---

## 6) Короткая подсказка для запросов к Codex/LLM
### 6.1) Универсальная вставка (“ленивый контекст”)
> Используй `docs/PROJECT_CONTEXT.md` и `docs/GLOSSARY.md` как источники правды.  
> Работай лениво: не перепечатывай документы целиком, ссылайся на секции.  
> Для контекста используй `docs/CONTEXT_SNAPSHOT.md`.

### 6.2) Пример: надёжный режим Spec → Tests/Proof → Code
> Используй skills: `workflow-spec-tests-code` и `test-verification-welding-short`.  
> Контекст: (вставить `docs/CONTEXT_SNAPSHOT.md`).  
> Задача: <описание>. Ограничения: <что нельзя менять>.  
> Выход: Spec + Tests/Proof + Code plan. Код не писать, пока не попрошу.

### 6.3) Пример: реализация минимальным патчем
> Используй skills: `patch-discipline-small-diffs` и `test-verification-welding-short`.  
> Контекст: (вставить `docs/CONTEXT_SNAPSHOT.md`).  
> Реализуй: <описание>. Разрешённые файлы: <список>.  
> Запрещено: рефакторинг/переименования/форматирование вне нужного.  
> Выход: патч + какие тесты/измерения нужны.

### 6.4) Пример: red-team review
> Используй skill: `red-team-review-welding`.  
> Контекст: (вставить `docs/CONTEXT_SNAPSHOT.md`).  
> Вот дифф/PR: <вставить>.  
> Найди риски/гонки/тайминги/нарушение safety-инвариантов и дай план воспроизведения/доказательства.

Конец.
