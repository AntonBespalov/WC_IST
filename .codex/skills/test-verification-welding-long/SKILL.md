---
name: test-verification-welding-long
version: 1.0.0
description: >
  Длинная (расширенная) версия skill по тестированию и верификации прошивки
  для источника сварочного тока (STM32G4 + FreeRTOS + TIM1 + внешние АЦП).
  Использовать, когда нужна глубокая проработка доказательств: HIL/SIL, fault-injection,
  доказательство таймингов на железе, DFT (Design-for-Test), record/replay и чек-листы.
  Для повседневной работы предпочтительнее короткий skill: test-verification-welding-short.
tags: ["stm32g4","freertos","tim1","welding","testing","verification","hil","sil","fault-injection","dft","timing"]
project_context: "docs/PROJECT_CONTEXT.md"
glossary: "docs/GLOSSARY.md"
related_skills:
  - "test-verification-welding-short"
  - "safety-invariants-welding"
  - "red-team-review-welding"
  - "patch-discipline-small-diffs"
when_to_use:
  - "проектирование архитектуры с акцентом на тестируемость (host/SIL/HIL/on-target)"
  - "планирование/ревью HIL стенда, fault-injection набора, доказательств таймингов"
  - "разбор сложных дефектов (тайминги, гонки, редкие аварии), построение record/replay"
  - "ревью схемы/платы на DFT: тест-пойнты, линии аварий, возможность инъекций сигналов"
outputs:
  - "Тестируемые требования + Evidence plan (unit/SIL/on-target/HIL/bench) + критерии приёмки"
  - "Fault model + минимум 5 fault-injection сценариев на затронутую функциональность"
  - "План инструментирования (GPIO/trace/логи/счётчики) + что мерить осциллографом"
  - "Топ-риски и как их ловим тестами"
---

# Skill: Тестирование и верификация (длинная версия) — сварочный контроллер (STM32G4)

## Как пользоваться
- Этот skill — **расширенный**. Используй его, когда нужен “план доказательств” на уровне системы.
- Для большинства задач лучше применять короткий: `test-verification-welding-short`.
- Детали железа/таймингов/политик не дублируй здесь: см. `docs/PROJECT_CONTEXT.md` и краткую вставку `docs/CONTEXT_SNAPSHOT.md`.

---

## Миссия
Сделать так, чтобы каждое архитектурное/кодовое решение было проверяемо тестами и измерениями.
Предпочитать объективные, измеримые доказательства предположениям.

---

## Контракт вывода по умолчанию (что ты обязан выдавать)
Когда тебя просят предложить/реализовать/изменить что-либо, по возможности сформируй:

1) **Тестируемые требования**: что должно выполняться, с единицами измерения и допусками.
2) **План доказательств (evidence plan)**: какой уровень тестов подтверждает каждое требование:
   - статические проверки
   - юнит-тесты на ПК (без HAL)
   - SIL (software-in-the-loop)
   - интеграционные тесты на МК (on-target)
   - HIL-тесты
   - испытания на стенде/системные
3) **Критерии приёмки**: измеримые пороги (latency, jitter, границы, время реакции на fault).
4) **Покрытие fault-injection**: ключевые отказы + ожидаемое безопасное поведение.
5) **План инструментирования**: какие сигналы/логи/таймстемпы снимать, чтобы это доказать.
6) **Риски**: топ-3 способа, как это может сломаться, и как тесты это поймают.

Если информации не хватает — задай минимально необходимые уточняющие вопросы.
Если уточнить нельзя — явно зафиксируй допущения.

---

## Непримиримые принципы для этого проекта
### P0 — Безопасное состояние должно обеспечиваться аппаратно
- Safety-критичное отключение НЕ должно зависеть от планирования RTOS или выполнения обычных ISR.
- Использовать аппаратный путь отключения (например, TIM1 BKIN/BKIN2) + независимый запрет драйверов (`DRV_EN/INH`), если предусмотрено схемой.
- Критические аварии должны защёлкиваться (никакого автоматического рестарта без явного recovery по политике).

### P1 — Любые заявления о таймингах должны быть доказуемы
Любая фраза типа “каждый период”, “выборка в середине периода”, “быстрое отключение”
должна сопровождаться планом измерений: GPIO-тогглы, trace или осциллограф.

### P2 — Разделять логику и железо
- Алгоритмы управления и измерений должны тестироваться юнит-тестами на ПК.
- Доступ к железу — через интерфейсы/адаптеры (HAL-слой), зависимости инжектировать в core.

### P3 — Нельзя слепо доверять данным измерений
Всегда закладывать:
- проверки правдоподобия
- детект “залипа”
- детект насыщения
- обработку ошибок связи/таймаутов
И политику: что делать при единичной плохой выборке vs стойком отказе.

### P4 — Предпочитать детерминированное поведение
- Критичные контуры имеют бюджет времени и измеряются на железе.
- Поведение при overruns определено (controlled stop или fault по политике).
- Никогда не “продолжаем работать вслепую”.

---

## Пирамида тестов для сварочной прошивки (что обязательно планировать)
### Слой A: Статические гейты качества
Фокус на классы дефектов:
- переполнения целых, signed/unsigned
- конкурентность (volatile/атомарность), границы ISR/RTOS
- неинициализированная память, необработанные ошибки, выход за границы

**Артефакт**: перечень включённых проверок + какие дефекты они ловят.

### Слой B: Host unit tests (core-логика)
Охват (без HAL):
- регулятор (ограничения, anti-windup, slew-rate)
- машина состояний
- парсер/валидатор команд и таймаутов
- фильтрация/масштабирование/диагностика измерений

**Артефакт**: список тестов + ожидаемые результаты + негативные тесты.

### Слой C: On-target интеграция (периферия + тайминги)
Проверки:
- тайминги PWM: момент применения управляющих воздействий
- SPI/DMA: start → complete, переполнения буферов, таймауты
- транспорт: периодичность/нагрузка/ошибки шины
- линии fault: попадание в аппаратный shutdown-path

**Обязательно**: доказать измерениями worst-case:
- jitter старта шага управления
- latency аппаратного отключения (fault → PWM safe)

### Слой D: HIL (прошивка целиком, без киловатт)
Эмуляция сигналов измерений + инъекции отказов:
- “норма” и характерные переходные процессы
- плохой контакт/пики/провалы
- stuck/sat/timeout
- ошибки/задержки обмена

**Артефакт**: сценарии + ожидаемые переходы состояний + pass/fail.

### Слой E: Силовой стенд/системные
Ступенчатый риск-подход:
- без силовой части → ограниченная мощность → эквивалент → полный режим
**Обязательно**: E-Stop / watchdog / driver-fault тесты, отсутствие непреднамеренного рестарта.

---

## Модель отказов: канонический список (используй как checklist)
### Группа 1 — Измерения/АЦП
- таймаут транзакции, ошибка кадра/CRC (если применимо), зависание DMA
- stuck-at, насыщение в рельсы, невозможный dI/dt
- дрейф нуля/провал self-check калибровки

### Группа 2 — Управление
- переполнения/NaN (если есть float), накрутка интегратора, неверные ограничители
- пропуск тика / overrun / рассинхрон выборка↔применение
- невалидные уставки/резкие смены режима

### Группа 3 — Обмен с ТК
- потеря команд > N мс, bus-off, повтор старого seq, повреждённые кадры
- флуд низкоприоритетных сообщений, вызывающий джиттер

### Группа 4 — Силовая часть/драйверы
- fault драйвера (DESAT/UVLO/OT/потеря ready)
- риск shoot-through при неверной конфигурации dead-time/комплементарности
- индикации undervoltage/overvoltage питания

### Группа 5 — MCU/система
- дедлок RTOS, переполнение стека, выключенные IRQ, зависание МК
- срабатывание внешнего watchdog

Для каждого отказа определить:
- детект (линия/софт-диагностика/таймаут)
- реакция (аппаратно / DRV_EN / controlled stop)
- latch/recovery
- отчётность (fault_flags/counters + snapshot/лог)

---

## Требования к инструментированию (доказательства, а не догадки)
### GPIO-тогглы тайминга (минимальный набор)
Вывести тест-пойнтами на плате:
- DBG_CTRL_TICK: high в начале шага управления, low в конце
- DBG_ADC_START: импульс на старте транзакции
- DBG_ADC_READY: импульс на completion
- DBG_PWM_APPLY: импульс при коммите новых значений
- DBG_FAULT_ENTRY: импульс при входе в софт-обработчик fault
Также наблюдать:
- BKIN_RAW (или эквивалентная линия аппаратного отключения)
- PWM_OUT (выход(ы) таймера)

### Метрики, которые нужно выдавать
- время выполнения шага управления (min/avg/max)
- jitter старта шага управления
- задержка измерительного тракта (start→ready)
- аппаратная задержка отключения: fault_line → PWM_OUT safe
- задержки/таймауты обмена
- счётчики ошибок (измерения/обмен/overrun)

---

## Record/Replay (если есть внешняя память/буфер)
Рекомендация: кольцевой буфер с pre/post-trigger на fault.

Минимальные поля записи:
- timestamp
- ключевые измерения (raw + filtered)
- уставка/seq
- управляющее воздействие (duty/enable request)
- состояние машины
- fault_flags + counters
- timing-статистика тика

Цели:
- регрессия фильтра/регулятора по “golden traces”
- воспроизведение дефектов по реальным логам
- сравнение настроек без силовых прогонов

---

## DFT (Design-for-Test): требования к схеме/плате (для ревью железа)
Требовать:
- тест-пойнты: линии аппаратного отключения, DRV_EN/INH, fault-линии, PWM-выходы, опорники АЦП, ключевые питания
- возможность подачи эталонных уровней/сигналов в измерительную цепь (порт калибровки/мультиплексор/режим)
- корректную топологию “OR” аварий (совместимость с open-collector, подтяжки, полярности)
- внешний watchdog, завязанный в disable path (если применимо)
- возможность безопасной HIL-инъекции fault/измерений без включения силовой части

---

## При реализации фич: обязательный чек-лист
Перед кодом:
- определить требование + метрику приёмки + уровень тестов
- оценить worst-case влияние на тайминги
- определить, какие отказы добавляет изменение

Во время кода:
- держать алгоритмы “чистыми” и тестируемыми; зависимости инжектировать
- добавить телеметрию: счётчики и fault-флаги
- обеспечить ограниченное время выполнения; определить поведение при overrun

После кода:
- добавить/расширить юнит-тесты
- добавить on-target GPIO-тогглы, если изменение тайминг-чувствительное
- обновить fault-injection сценарии и ожидаемое поведение (класс, latch/recovery, отчётность)

---

## Правила стиля ответа (для модели)
- Никогда не отвечать “должно работать” без плана доказательств.
- Всегда указывать, как это измерить/проверить на реальном железе (GPIO/trace/осциллограф/логи).
- Предпочитать конкретные единицы, пороги и порядок событий (если пороги не зафиксированы — отметить как TBD и сослаться на docs).
- Если “схема проектируется” — проактивно предложить shutdown-path и DFT-топологию.

Конец.
